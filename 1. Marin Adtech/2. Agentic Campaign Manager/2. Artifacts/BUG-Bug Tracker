# Marin Software - Agentic Campaign Manager - Master Bug Tracker

**Version:** 1.0  
**Created:** January 2025  
**Last Updated:** 2025-11-09 - Mid-Day Update
**Project:** Agentic Campaign Manager Module  
**Environment:** Development  
**Status:** Ready for Bug Tracking  
**Aligned Documents:** PRD v2.0 | TaskList v2.0 | Tech Stack v1.0  

---

## üìä QUICK SUMMARY

**Total Bugs:** 20  
**Enhancements:** 0 üí°  
**Known Limitations:** 0 üìã  
**Blocking Issues:** 0  
**Production Status:** ‚úÖ **READY** - No critical bugs identified  
**Demo Ready:** ‚úÖ **READY** - No blocking issues  

### Functional Bugs Breakdown

- **üî¥ Critical:** 0 bugs
- **üü† High Priority:** 1 bug (was 5, BUG-002, BUG-011, BUG-017, BUG-018 fixed, 1 remaining: BUG-014)
- **üü° Medium Priority:** 7 bugs (was 15, BUG-001, BUG-003, BUG-004, BUG-006, BUG-009, BUG-016, BUG-019, BUG-020 fixed, 7 remaining)
- **üü¢ Low Priority:** 0 bugs
- **üìã Known Limitations:** 0

### Development Status

- **MVP Phase:** ‚úÖ Complete
- **CSV/URL Campaign Generation:** ‚úÖ Complete
- **Testing:** ‚è≥ In Progress
- **Production Deployment:** ‚è≥ Pending

**Estimated Fix Time:** 8-14.5 hours (8 bugs remaining: 1 High, 7 Medium)

---

## üìã BUG SUMMARY TABLE

| Bug ID | Title | Priority | Category | Status | Fix Time |
|--------|-------|----------|----------|--------|----------|
| ‚úÖ BUG-001 | Drag-and-Drop Zone Resizes During Drag Operation | üü° Medium | UI/UX | üü¢ Fixed | 30-60 min |
| ‚úÖ BUG-002 | CSV Upload Overwrites Existing Products Instead of Merging | üü† High | CSV Processing | üü¢ Fixed | 1-2 hours |
| ‚úÖ BUG-003 | Edit/Delete Buttons Scroll with Table Content Instead of Being Fixed | üü° Medium | UI/UX | üü¢ Fixed | 45-60 min |
| ‚úÖ BUG-004 | Product Tab Navigation Scrolls Off-Screen on Pattern Learning Page | üü° Medium | UI/UX | üü¢ Fixed | 30-45 min |
| BUG-005 | URLs Not Verified to Exist/Be Reachable During CSV Upload | üü° Medium | CSV Processing | üî¥ Open | 1-2 hours |
| ‚úÖ BUG-006 | Campaign Preview Pages Should Match Dashboard/Details Layout with PREVIEW Badge | üü° Medium | UI/UX | üü¢ Fixed | 2-3 hours |
| BUG-007 | Campaign Dashboard Enhancement: Hashtags, Tag Filtering, and Batch Actions | üü° Medium | UI/UX, Data Management | üî¥ Open | 3-5 hours |
| BUG-008 | Campaign Dashboard Should Filter by Product Category with Batch Actions | üü° Medium | UI/UX, Data Management | üî¥ Open | 2-3 hours |
| ‚úÖ BUG-009 | Campaign Dashboard Filter Bar Should Remain Static While Scrolling | üü° Medium | UI/UX | üü¢ Fixed | 30-45 min |
| BUG-010 | Performance Dashboard Header Should Remain Static While Scrolling | üü° Medium | UI/UX | üî¥ Open | 30-45 min |
| ‚úÖ BUG-011 | Performance Dashboard Export CSV Fails with "point.date.toISOString is not a function" | üü† High | Export, Data Processing | üü¢ Fixed | 30-60 min |
| BUG-012 | Inline Editing Behavior Issues in Campaign Preview | üü° Medium | UI/UX, Functionality | üî¥ Open | 1-2 hours |
| BUG-013 | RSA Ad Headlines Display Not Optimized in Campaign Preview | üü° Medium | UI/UX | üî¥ Open | 1-2 hours |
| BUG-014 | Keyword Deletion Deletes Incorrect Item in Campaign Preview | üü† High | Functionality, Data Integrity | üî¥ Open | 1-2 hours |
| BUG-015 | Validation Errors Not Linked to Elements on Page in Campaign Preview | üü° Medium | UI/UX, Functionality | üî¥ Open | 1-2 hours |
| ‚úÖ BUG-016 | Ad Group Name Display Not Updated After Inline Edit | üü° Medium | UI/UX, Functionality | üü¢ Fixed | 30-60 min |
| ‚úÖ BUG-017 | Export Validation Fails with Empty Errors Array | üü† High | Export, Validation | üü¢ Fixed | 30-60 min |
| ‚úÖ BUG-018 | CSV Upload Errors Not Displayed in UI | üü† High | CSV Processing, UI/UX | üü¢ Fixed | 30-60 min |
| ‚úÖ BUG-019 | Empty CSV Files Not Detected and Rejected with Error Messages | üü° Medium | CSV Processing, Validation | üü¢ Fixed | 30-45 min |
| ‚úÖ BUG-020 | Missing Optional Columns Not Validated or Warned About | üü° Medium | CSV Processing, Validation | üü¢ Fixed | 45-60 min |

**Legend:**
- üî¥ Critical = Blocking deployment/demo
- üü† High = Significant UX issue, fix soon
- üü° Medium = Notable issue, fix after submission
- üü¢ Low = Polish/enhancement, fix when time permits

**Totals:**

- üî¥ Critical: 0 bugs
- üü† High: 1 bug (1 remaining: BUG-014)
- üü° Medium: 7 bugs (7 remaining: BUG-005, BUG-007, BUG-008, BUG-010, BUG-012, BUG-013, BUG-015)
- üü¢ Low: 0 bugs
- ‚úÖ Fixed: 12 bugs (BUG-001, BUG-002, BUG-003, BUG-004, BUG-006, BUG-009, BUG-011, BUG-016, BUG-017, BUG-018, BUG-019, BUG-020)

---

## √∞≈∏≈Ω¬Ø CURRENT STATUS

### Development Phase
**Date:** January 2025  
**Phase:** MVP Complete - Testing & Production Preparation  
**Overall Status:** ‚úÖ **READY FOR PRODUCTION**

**Implementation Complete:** ‚úÖ All Phases Complete

- ‚úÖ Phase 0: Foundation & Setup - COMPLETE
- ‚úÖ Phase 1: CSV/URL Input Processing - COMPLETE
- ‚úÖ Phase 2: Pattern Learning & Campaign Generation - COMPLETE
- ‚úÖ Phase 3: Preview & Export - COMPLETE
- ‚úÖ Conversational Interface - COMPLETE
- ‚úÖ Campaign Management - COMPLETE
- ‚úÖ Performance Dashboard - COMPLETE

**Demo Readiness:** ‚úÖ **READY**
- All core features implemented and functional
- No blocking issues identified
- System ready for end-to-end testing
- Production deployment pending

---

## √∞≈∏¬ê‚Ä∫ FUNCTIONAL BUGS (Priority Ordered)

### BUG-001: Drag-and-Drop Zone Resizes During Drag Operation

**Priority:** üü° Medium  
**Category:** UI/UX  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** CSV Upload / Drag-and-Drop Zone  
**Estimated Fix Time:** 30-60 minutes

**Description:**
When dragging a CSV file over the drag-and-drop zone in the Bulk Campaign Generation screen, the drop zone visually resizes during the drag operation. The border and container dimensions change when `isDragActive` becomes true, causing a jarring visual effect. The drop zone should maintain consistent dimensions throughout the drag operation.

**Steps to Reproduce:**
1. Navigate to Bulk Campaign Generation screen (`/campaigns/csv-upload`)
2. Select a CSV file from the file system
3. Begin dragging the file over the drag-and-drop zone
4. Observe the drop zone as the file is dragged over it
5. Expected: Drop zone should maintain consistent size and appearance
6. Actual: Drop zone border and dimensions change/resize during drag operation

**Impact:**
- Visual inconsistency during drag operation
- Unprofessional appearance
- Potential user confusion
- Minor UX issue that affects polish

**Possible Solution:**
The issue is caused by content changes between `isDragActive` states in `CSVUploadComponent.tsx`. When `isDragActive` is true, the component shows different content (just icon and "Drop your CSV file here..."), while the inactive state shows more content (icon, text, column requirements, file size). This content difference causes the container to resize.

**Fix Approach:**
1. **Option 1 (Recommended):** Maintain consistent content structure and use CSS to show/hide elements rather than conditionally rendering different content:
   - Keep all content elements in the DOM
   - Use `opacity` and `visibility` or `display: none` to toggle visibility
   - Ensure the container maintains fixed dimensions with `min-height` or fixed height
   - Use absolute positioning for overlay states if needed

2. **Option 2:** Use fixed dimensions on the Card component:
   - Add `min-height` to the Card to prevent resizing
   - Use `height: auto` with a minimum height constraint
   - Ensure padding remains consistent

3. **Option 3:** Use CSS transitions with fixed dimensions:
   - Set explicit width and height on the drop zone
   - Use `overflow: hidden` to prevent content overflow
   - Animate only visual properties (border, background) not dimensions

**Recommended Implementation:**
```tsx
// In CSVUploadComponent.tsx, modify the Card styling:
<Card
  {...getRootProps()}
  className={cn(
    'cursor-pointer transition-all duration-200 hover:border-primary',
    'min-h-[300px]', // Add fixed minimum height
    isDragActive && 'border-primary bg-primary/5',
    isUploading && 'pointer-events-none opacity-70'
  )}
>
  <CardContent className="flex flex-col items-center justify-center p-12 text-center min-h-[300px]">
    {/* Keep content structure consistent, use conditional visibility */}
    <div className={cn(isDragActive ? 'block' : 'hidden')}>
      <UploadCloudIcon className="h-12 w-12 text-primary mb-4" />
      <p className="text-lg font-medium">Drop your CSV file here...</p>
    </div>
    <div className={cn(isDragActive ? 'hidden' : 'block')}>
      {/* Existing inactive state content */}
    </div>
  </CardContent>
</Card>
```

**Related Files:**
- `src/components/csv-upload/CSVUploadComponent.tsx` - Main component with drag-and-drop logic
- `src/components/csv-upload/CSVUploadScreen.tsx` - Parent screen component

---

### BUG-002: CSV Upload Overwrites Existing Products Instead of Merging

**Priority:** üü† High
**Category:** CSV Processing
**Status:** ‚úÖ Fixed
**Discovered:** January 2025
**Fixed:** January 2025
**Component:** CSV Upload / Product Management
**Estimated Fix Time:** 1-2 hours

**Description:**
After a CSV file has been successfully loaded and products are displayed in the preview, the drag-and-drop zone remains active. If another CSV file is dropped, it completely overwrites the existing products preview instead of merging/adding new products. The system should accumulate products from multiple CSV uploads, only adding products that don't already exist (deduplication), and this cycle should be infinitely repeatable for many CSV files.

**Steps to Reproduce:**
1. Navigate to Bulk Campaign Generation screen (`/campaigns/csv-upload`)
2. Upload first CSV file with products (e.g., 3 products)
3. Verify products appear in preview table
4. Drag and drop a second CSV file with different products (e.g., 2 new products)
5. Expected: Products from both CSVs should be displayed (5 total products)
6. Actual: Only products from the second CSV are displayed (2 products, first CSV products are lost)

**Impact:**
- **High Priority:** Data loss - users lose previously uploaded products
- Users cannot combine products from multiple CSV files
- Workflow limitation - requires manually combining CSVs before upload
- Poor user experience - unexpected behavior
- Potential frustration and time waste

**Root Cause Analysis:**
The issue is in `CSVUploadScreen.tsx` in the `handleParseComplete` function (line 30-38). Currently, it uses:
```tsx
setProducts(result.products);  // This REPLACES all products
```
This directly replaces the entire products array instead of merging with existing products.

**Solution Approach:**

### Option 1: Merge with URL-Based Deduplication (Recommended)

**Implementation Strategy:**
1. **Modify `handleParseComplete` in `CSVUploadScreen.tsx`:**
   - Instead of `setProducts(result.products)`, merge new products with existing ones
   - Use URL as the unique identifier for deduplication (normalize URLs for comparison)
   - Only add products that don't already exist (by URL)
   - Preserve existing product IDs for products that already exist
   - Update existing products if new CSV has updated data (optional - could be configurable)

2. **Deduplication Logic:**
   ```tsx
   const handleParseComplete = (result: ProductParsingResult) => {
     setProducts(prevProducts => {
       // Create a map of existing products by normalized URL
       const existingProductsMap = new Map(
         prevProducts.map(p => [normalizeUrl(p.url), p])
       );
       
       // Merge new products, skipping duplicates
       const newProducts = result.products.filter(product => {
         const normalizedUrl = normalizeUrl(product.url);
         return !existingProductsMap.has(normalizedUrl);
       });
       
       // Combine existing and new products
       return [...prevProducts, ...newProducts];
     });
     
     // Merge errors and warnings (append, don't replace)
     setErrors(prevErrors => [...prevErrors, ...result.errors]);
     setWarnings(prevWarnings => [...prevWarnings, ...result.warnings]);
   };
   
   // Helper function to normalize URLs for comparison
   const normalizeUrl = (url: string): string => {
     try {
       const urlObj = new URL(url);
       return urlObj.href.toLowerCase().trim();
     } catch {
       return url.toLowerCase().trim();
     }
   };
   ```

3. **Handle Warnings/Errors:**
   - Accumulate warnings from all uploads (show which CSV caused which warning)
   - Track errors per product (don't clear previous errors)
   - Optionally show a notification when duplicates are skipped

4. **UI Enhancements:**
   - Show count of new products added vs duplicates skipped
   - Display a toast notification: "Added X new products. Y duplicates skipped."
   - Optionally show which products came from which CSV (could add `uploadedFrom` field)
   - Add a "Clear All" button to reset products if needed

5. **File Tracking (Optional Enhancement):**
   - Track uploaded file names to show product source
   - Add `uploadedFrom?: string` to `ProductInput` type (optional)
   - Display file name in product preview table

### Option 2: Update Existing Products on Duplicate (Alternative)

If the same URL appears in a new CSV, update the existing product with new data:
```tsx
const handleParseComplete = (result: ProductParsingResult) => {
  setProducts(prevProducts => {
    const existingMap = new Map(prevProducts.map(p => [normalizeUrl(p.url), p]));
    
    result.products.forEach(newProduct => {
      const normalizedUrl = normalizeUrl(newProduct.url);
      if (existingMap.has(normalizedUrl)) {
        // Update existing product
        const existing = existingMap.get(normalizedUrl)!;
        Object.assign(existing, newProduct);
      } else {
        // Add new product
        prevProducts.push(newProduct);
      }
    });
    
    return [...prevProducts];
  });
};
```

**Recommended Implementation:**
- Use **Option 1** (skip duplicates) as default behavior
- Add a configuration option or UI toggle for "Update existing products" vs "Skip duplicates"
- Implement URL normalization for robust deduplication
- Add user feedback (toast notifications) for merge results
- Consider adding a "Clear All Products" button for reset functionality

**Additional Considerations:**
1. **10 Product Limit:** The current MVP has a 10 product limit. After merging, check if total exceeds 10 and show appropriate warning/limit.
2. **Validation:** Re-validate all products after merge to ensure no validation errors
3. **Performance:** For large CSV files, consider debouncing or batching the merge operation
4. **URL List Input:** Apply same merge logic to URL list input for consistency

**Related Files:**
- `src/components/csv-upload/CSVUploadScreen.tsx` - Main screen with `handleParseComplete` function (line 30-38)
- `src/components/csv-upload/CSVUploadComponent.tsx` - CSV upload component
- `src/components/csv-upload/URLListInput.tsx` - URL list input (should have same merge behavior)
- `src/types/product.types.ts` - Product type definitions (may need to add `uploadedFrom` field)

**Testing Considerations:**
- Test with multiple CSV files containing overlapping URLs
- Test with same product appearing in different CSVs
- Test with 10+ products total (limit handling)
- Test URL normalization (http vs https, trailing slashes, etc.)
- Test error/warning accumulation across multiple uploads

---

### BUG-003: Edit/Delete Buttons Scroll with Table Content Instead of Being Fixed

**Priority:** üü° Medium
**Category:** UI/UX
**Status:** üü¢ Fixed
**Discovered:** January 2025
**Fixed:** January 2025
**Component:** Product Preview / CSV Upload
**Estimated Fix Time:** 45-60 minutes
**Actual Fix Time:** ~45 minutes

**Description:**
The product preview table after CSV upload has edit and delete buttons in the Actions column, but these buttons are part of the horizontally scrollable table area. When the table content is wider than the viewport and users scroll horizontally, the edit/delete buttons scroll with the content and become hidden. The Actions column (with edit/delete buttons) should be fixed/sticky on the right side, remaining visible even when the table scrolls horizontally.

**Steps to Reproduce:**
1. Navigate to Bulk Campaign Generation screen (`/campaigns/csv-upload`)
2. Upload a CSV file with products that have long URLs or descriptions
3. Verify products appear in the preview table
4. Observe that the table has horizontal scroll when content is wide
5. Scroll the table horizontally to the right
6. Expected: Edit/Delete buttons should remain visible in a fixed column on the right
7. Actual: Edit/Delete buttons scroll with the table content and become hidden when scrolling right

**Impact:**
- Users cannot access edit/delete buttons when table is scrolled horizontally
- Poor user experience - actions are not always accessible
- Users must scroll back to access edit/delete functionality
- Workflow inefficiency - cannot easily edit or delete products when viewing wide content
- Common UX pattern violation - action buttons should remain accessible

**Current Implementation:**
The `ProductPreview.tsx` component has the Actions column inside the scrollable table (lines 186-349):
- Table is wrapped in `<div className="rounded-md border overflow-x-auto">` (line 186)
- Actions column is part of the table structure (line 195, 303)
- When table scrolls horizontally, all columns including Actions scroll together
- Edit and delete buttons are in the Actions column (lines 324-343)

**Root Cause:**
The Actions column is inside the scrollable container, so it scrolls with the rest of the table content. The table needs a sticky/fixed Actions column that remains visible during horizontal scrolling.

**Solution Approach:**

### Option 1: Sticky Right Column (Recommended)

**Implementation Strategy:**
1. **Restructure Table Layout:**
   - Separate the scrollable content area from the fixed Actions column
   - Use CSS `position: sticky` with `right: 0` for the Actions column
   - Ensure Actions column has a background color to prevent content showing through
   - Add appropriate z-index to ensure Actions column appears above scrolling content

2. **CSS Sticky Column Implementation:**
   ```tsx
   // In ProductPreview.tsx, modify the table structure:
   <div className="rounded-md border overflow-x-auto relative">
     <Table>
       <TableHeader>
         <TableRow>
           {/* Regular scrollable columns */}
           <TableHead className="min-w-[150px]">Name</TableHead>
           <TableHead className="min-w-[200px]">URL</TableHead>
           {/* ... other columns ... */}
           
           {/* Fixed Actions column */}
           <TableHead className="min-w-[120px] text-right sticky right-0 bg-background z-10">
             Actions
           </TableHead>
         </TableRow>
       </TableHeader>
       <TableBody>
         {products.map((product) => (
           <TableRow key={product.id}>
             {/* Regular scrollable cells */}
             <TableCell>...</TableCell>
             
             {/* Fixed Actions cell */}
             <TableCell className="text-right sticky right-0 bg-background z-10">
               {/* Edit/Delete buttons */}
             </TableCell>
           </TableRow>
         ))}
       </TableBody>
     </Table>
   </div>
   ```

3. **Alternative: Split Layout Approach:**
   - Create two separate sections: scrollable content table and fixed Actions column
   - Use flexbox or grid to position them side by side
   - Actions column remains fixed while content scrolls

**Recommended Implementation:**
```tsx
// In ProductPreview.tsx, modify the table structure:
<div className="rounded-md border overflow-x-auto relative">
  <Table>
    <TableHeader>
      <TableRow>
        <TableHead className="min-w-[150px]">Name</TableHead>
        <TableHead className="min-w-[200px]">URL</TableHead>
        <TableHead className="min-w-[120px]">Category</TableHead>
        <TableHead className="min-w-[100px]">Price</TableHead>
        <TableHead className="min-w-[200px]">Description</TableHead>
        {/* Fixed Actions column */}
        <TableHead className="min-w-[120px] text-right sticky right-0 bg-background z-10 border-l">
          Actions
        </TableHead>
      </TableRow>
    </TableHeader>
    <TableBody>
      {products.map((product) => {
        const isEditing = editingId === product.id;
        return (
          <TableRow key={product.id}>
            {/* Scrollable cells */}
            <TableCell>...</TableCell>
            
            {/* Fixed Actions cell */}
            <TableCell className="text-right sticky right-0 bg-background z-10 border-l">
              {isEditing ? (
                <div className="flex justify-end gap-1">
                  {/* Save/Cancel buttons */}
                </div>
              ) : (
                <div className="flex justify-end gap-1">
                  <Button
                    size="sm"
                    variant="ghost"
                    onClick={() => handleEdit(product)}
                    type="button"
                  >
                    <PencilIcon className="h-3 w-3" />
                  </Button>
                  <Button
                    size="sm"
                    variant="ghost"
                    onClick={() => handleRemove(product.id)}
                    type="button"
                    className="text-destructive hover:text-destructive"
                  >
                    <TrashIcon className="h-3 w-3" />
                  </Button>
                </div>
              )}
            </TableCell>
          </TableRow>
        );
      })}
    </TableBody>
  </Table>
</div>
```

**CSS Considerations:**
- Use `position: sticky` with `right: 0` for the Actions column
- Add `background-color` to prevent content showing through when scrolling
- Add `z-index` to ensure Actions column appears above scrolling content
- Add `border-left` to visually separate the fixed column
- Ensure proper width constraints to prevent layout issues

**Additional Enhancements:**
- Add shadow or border to the fixed column for better visual separation
- Ensure Actions column has sufficient width for buttons
- Test on different screen sizes to ensure sticky column works correctly
- Consider adding a visual indicator that the column is fixed

**Related Files:**
- `src/components/csv-upload/ProductPreview.tsx` - Product preview component with table structure (lines 186-349)
- `src/components/ui/table.tsx` - Table component (may need styling adjustments)

**Testing Considerations:**
- Test with wide table content that requires horizontal scrolling
- Verify Actions column remains visible when scrolling horizontally
- Test edit/delete button functionality with sticky column
- Test on different screen sizes and viewport widths
- Verify Actions column background doesn't show content bleeding through
- Test with multiple products to ensure sticky column works for all rows
- Verify z-index and layering work correctly
- Test on different browsers (sticky positioning support)

**Fix Implementation:**

The fix was implemented using Option 1 (Sticky Right Column) as recommended. Changes were made to `src/components/csv-upload/ProductPreview.tsx`:

1. **Line 195 - TableHead for Actions column:**
   - Added `sticky right-0` to fix the column to the right side
   - Added `bg-background` to ensure proper background color (prevents content showing through)
   - Added `shadow-[-4px_0_6px_-2px_rgba(0,0,0,0.1)]` for a subtle left shadow to indicate the sticky column

2. **Line 303 - TableCell for Actions column:**
   - Applied the same sticky styling: `sticky right-0 bg-background shadow-[-4px_0_6px_-2px_rgba(0,0,0,0.1)]`
   - Ensures all action buttons remain fixed during horizontal scroll

The implementation successfully makes the Actions column (containing Edit/Delete buttons) remain visible and accessible even when the table content is scrolled horizontally. The subtle shadow provides a visual indicator that separates the fixed column from the scrolling content.

**Files Modified:**
- `src/components/csv-upload/ProductPreview.tsx` (lines 195, 303)

**Verification:**
- Actions column now remains fixed on the right side during horizontal scrolling
- Edit and delete buttons are always accessible
- Background color properly masks scrolling content
- Subtle shadow provides visual separation

---

### BUG-004: Product Tab Navigation Scrolls Off-Screen on Pattern Learning Page

**Priority:** üü° Medium
**Category:** UI/UX
**Status:** üü¢ Fixed
**Discovered:** January 2025
**Fixed:** January 2025
**Component:** Pattern Learning / Tab Navigation
**Estimated Fix Time:** 30-45 minutes
**Actual Fix Time:** ~15 minutes

**Description:**
On the Pattern Learning page, after generating campaigns for CSV uploaded products, the product tab navigation (TabsList showing product names like "Yamaha SR400", "Honda CB350", "Triumph Thruxton", etc.) scrolls off-screen when users scroll through the pattern data below. The tab navigation should remain sticky/fixed at the top of the content area, allowing users to easily switch between product views without losing their place or having to scroll back up.

**Steps to Reproduce:**
1. Navigate to Bulk Campaign Generation screen (`/campaigns/csv-upload`)
2. Upload a CSV file with multiple products
3. Click "Generate Campaigns" and proceed through the workflow
4. Navigate to Pattern Learning page (`/campaigns/pattern-learning`)
5. Verify product tabs appear at the top (e.g., "Yamaha SR400", "Honda CB350", etc.)
6. Scroll down through the pattern data content
7. Expected: Product tab navigation should remain visible at the top
8. Actual: Product tab navigation scrolls off-screen with the content

**Impact:**
- Users cannot easily switch between products while viewing pattern data
- Poor user experience - must scroll back to top to change products
- Workflow inefficiency - interrupts pattern review process
- Common UX pattern violation - navigation should remain accessible
- Users may lose their place when scrolling back up

**Current Implementation:**
The `PatternLearningScreen.tsx` component has the TabsList inside the main content area (lines 259-268):
- TabsList is inside the main content div (line 238: `<div className="mx-auto max-w-7xl space-y-6">`)
- TabsList is not sticky or fixed (line 261: `<TabsList className="grid w-full"...>`)
- When content below is scrolled, the TabsList scrolls with it
- No sticky positioning applied to the tab navigation

**Root Cause:**
The TabsList is part of the normal document flow and is not positioned as sticky. When users scroll through the pattern data content below, the entire page scrolls, including the tab navigation.

**Solution Approach:**

### Option 1: Sticky Tab Navigation (Recommended)

**Implementation Strategy:**
1. **Make TabsList Sticky:**
   - Apply CSS `position: sticky` with `top: 0` to the TabsList
   - Add background color to prevent content showing through
   - Add appropriate z-index to ensure tabs appear above scrolling content
   - Add shadow or border for visual separation when sticky

2. **CSS Sticky Implementation:**
   ```tsx
   // In PatternLearningScreen.tsx, modify the TabsList:
   <Tabs value={activeProductTab} onValueChange={setActiveProductTab}>
     <TabsList 
       className="grid w-full sticky top-0 bg-background z-10 border-b shadow-sm"
       style={{ gridTemplateColumns: `repeat(${products.length}, minmax(0, 1fr))` }}
     >
       {products.map((product: any, index: number) => (
         <TabsTrigger key={product.id} value={String(index)}>
           <PackageIcon className="h-4 w-4 mr-2" />
           <span className="truncate max-w-[150px]">{product.name}</span>
         </TabsTrigger>
       ))}
     </TabsList>
     {/* TabsContent below */}
   </Tabs>
   ```

3. **Alternative: Sticky Container Approach:**
   - Wrap the TabsList in a sticky container div
   - Apply sticky positioning to the container
   - Ensure proper spacing and background

**Recommended Implementation:**
```tsx
// In PatternLearningScreen.tsx, modify the Tabs section:
{products.length > 0 && productPatterns.length > 0 && (
  <Tabs value={activeProductTab} onValueChange={setActiveProductTab}>
    {/* Sticky tab navigation */}
    <div className="sticky top-0 bg-background z-10 border-b shadow-sm mb-6">
      <TabsList 
        className="grid w-full"
        style={{ gridTemplateColumns: `repeat(${products.length}, minmax(0, 1fr))` }}
      >
        {products.map((product: any, index: number) => (
          <TabsTrigger key={product.id} value={String(index)}>
            <PackageIcon className="h-4 w-4 mr-2" />
            <span className="truncate max-w-[150px]">{product.name}</span>
          </TabsTrigger>
        ))}
      </TabsList>
    </div>

    {/* Tab content below (scrollable) */}
    {productPatterns.map((productPattern: CampaignPatterns, index: number) => (
      <TabsContent key={products[index].id} value={String(index)} className="space-y-6">
        {/* Pattern content */}
      </TabsContent>
    ))}
  </Tabs>
)}
```

**CSS Considerations:**
- Use `position: sticky` with `top: 0` for the tab navigation
- Add `background-color` (bg-background) to prevent content showing through
- Add `z-index` (z-10) to ensure tabs appear above scrolling content
- Add `border-b` or `shadow-sm` for visual separation when sticky
- Consider adding padding to the sticky container for better spacing

**Additional Enhancements:**
- Add smooth scroll behavior when switching tabs
- Consider adding a visual indicator when tabs are sticky
- Ensure tabs work correctly on mobile devices
- Test with many products (horizontal scrolling of tabs)

**Related Files:**
- `src/components/pattern-learning/PatternLearningScreen.tsx` - Pattern learning screen with tab navigation (lines 259-293)
- `src/components/ui/tabs.tsx` - Tabs component (may need styling adjustments)

**Testing Considerations:**
- Test with multiple products (3+ tabs)
- Verify tab navigation remains visible when scrolling through pattern data
- Test tab switching functionality with sticky navigation
- Test on different screen sizes and viewport heights
- Verify tab navigation background doesn't show content bleeding through
- Test with long pattern data that requires significant scrolling
- Verify z-index and layering work correctly
- Test on different browsers (sticky positioning support)
- Test with many products (horizontal scrolling of tabs)

**Fix Applied:**

The fix was implemented by applying CSS sticky positioning directly to the TabsList component in `PatternLearningScreen.tsx:261`.

**Changes Made:**
- Modified `TabsList` className from `"grid w-full"` to `"grid w-full sticky top-0 z-10 bg-background"`
- Added `sticky` class for sticky positioning
- Added `top-0` to stick the element to the top of the viewport (0px from top)
- Added `z-10` to ensure the tab navigation appears above scrolling content
- Added `bg-background` to provide a solid background and prevent content bleeding through

**Code Change:**
```tsx
// Before (line 261):
<TabsList className="grid w-full" style={{ gridTemplateColumns: `repeat(${products.length}, minmax(0, 1fr))` }}>

// After (line 261):
<TabsList className="grid w-full sticky top-0 z-10 bg-background" style={{ gridTemplateColumns: `repeat(${products.length}, minmax(0, 1fr))` }}>
```

**Result:**
The product tab navigation now remains fixed at the top of the viewport when users scroll through the pattern data, allowing easy switching between products without losing their place or scrolling back up.

**Files Modified:**
- `src/components/pattern-learning/PatternLearningScreen.tsx` (line 261)

---

### BUG-005: URLs Not Verified to Exist/Be Reachable During CSV Upload

**Priority:** üü° Medium  
**Category:** CSV Processing  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** CSV Upload / URL Validation  
**Estimated Fix Time:** 1-2 hours

**Description:**
When uploading a CSV file with product URLs, the system only validates that URLs are well-formed (correct format with http:// or https:// protocol) but does not verify that the URLs actually exist or are reachable. Invalid, broken, or non-existent URLs can pass validation and cause issues downstream during campaign generation. The system should optionally verify that URLs are accessible before accepting them.

**Steps to Reproduce:**
1. Navigate to Bulk Campaign Generation screen (`/campaigns/csv-upload`)
2. Create a CSV file with a product that has a well-formed but non-existent URL (e.g., `https://example.com/nonexistent-product-page`)
3. Upload the CSV file
4. Expected: System should verify URL exists and is reachable, or at least warn about unverified URLs
5. Actual: URL passes validation if it's well-formed, even if it doesn't exist or is unreachable

**Impact:**
- Invalid URLs can be accepted and cause issues during campaign generation
- Broken links in generated campaigns
- Poor user experience - users discover invalid URLs only after campaign generation
- Potential wasted API calls and processing time for invalid URLs
- Campaigns may fail or produce errors when trying to use invalid URLs

**Current Implementation:**
The URL validation only checks format, not existence:
- `productParsingService.ts` (line 27-34): `isValidURL()` function only checks URL format using `new URL()` and protocol validation
- `validationService.ts` (line 105-118): `validateUrl()` function only validates format, not reachability
- No HTTP requests are made to verify URLs exist
- No network checks to verify URLs are accessible

**Root Cause:**
The validation logic only checks if the URL string is well-formed (valid URL format with http/https protocol) but does not make any HTTP requests to verify the URL actually exists or is reachable.

**Solution Approach:**

### Option 1: Optional URL Verification (Recommended)

**Implementation Strategy:**
1. **Add URL Verification Service:**
   - Create a URL verification service that makes HEAD or GET requests to verify URLs
   - Use axios or fetch to check if URL is reachable
   - Set reasonable timeout (e.g., 5-10 seconds per URL)
   - Handle errors gracefully (network errors, timeouts, 404s, etc.)

2. **Verification Logic:**
   ```tsx
   // In productParsingService.ts or new urlVerificationService.ts:
   async function verifyUrlExists(url: string): Promise<{ exists: boolean; error?: string }> {
     try {
       const response = await axios.head(url, {
         timeout: 5000, // 5 second timeout
         maxRedirects: 5,
         validateStatus: (status) => status < 500, // Accept 2xx, 3xx, 4xx as "exists"
       });
       
       // Consider 2xx and 3xx as valid, 4xx as potentially invalid
       if (response.status >= 200 && response.status < 400) {
         return { exists: true };
       } else if (response.status === 404) {
         return { exists: false, error: 'URL not found (404)' };
       } else {
         return { exists: false, error: `URL returned status ${response.status}` };
       }
     } catch (error) {
       if (axios.isAxiosError(error)) {
         if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
           return { exists: false, error: 'URL is not reachable' };
         }
         if (error.code === 'ETIMEDOUT') {
           return { exists: false, error: 'URL verification timed out' };
         }
       }
       return { exists: false, error: 'Failed to verify URL' };
     }
   }
   ```

3. **Integration Options:**
   - **Option A (Recommended):** Make verification optional with a toggle/checkbox
     - Add "Verify URLs" checkbox in CSV upload screen
     - Only verify if user opts in (to avoid delays for large CSVs)
     - Show progress indicator during verification
   
   - **Option B:** Always verify but in background
     - Verify URLs asynchronously after CSV parsing
     - Show warnings for invalid URLs but don't block workflow
     - Allow users to proceed with warnings
   
   - **Option C:** Verify on-demand
     - Add "Verify URLs" button after CSV upload
     - Users can manually trigger verification
     - Show results with warnings/errors

4. **User Feedback:**
   - Show verification progress (e.g., "Verifying URL 3 of 10...")
   - Display warnings for unreachable URLs
   - Allow users to proceed with warnings or fix URLs
   - Show which URLs failed verification

**Recommended Implementation:**
```tsx
// In productParsingService.ts, add URL verification:
export async function parseCSVWithVerification(
  csvContent: string,
  verifyUrls: boolean = false
): Promise<ProductParsingResult> {
  const result = await parseCSV(csvContent);
  
  if (verifyUrls && result.products.length > 0) {
    // Verify URLs in parallel with rate limiting
    const verificationPromises = result.products.map(async (product) => {
      if (product.url) {
        const verification = await verifyUrlExists(product.url);
        if (!verification.exists) {
          result.warnings.push(
            `URL may be invalid for "${product.name}": ${verification.error || 'URL not reachable'}`
          );
        }
      }
    });
    
    await Promise.all(verificationPromises);
  }
  
  return result;
}

// In CSVUploadScreen.tsx, add verification option:
const [verifyUrls, setVerifyUrls] = useState(false);

// Add checkbox:
<label>
  <input 
    type="checkbox" 
    checked={verifyUrls} 
    onChange={(e) => setVerifyUrls(e.target.checked)}
  />
  Verify URLs are reachable (may take longer)
</label>
```

**Performance Considerations:**
- URL verification can be slow (network requests)
- For 10 products, verification could take 10-50 seconds
- Consider parallel verification with rate limiting
- Add timeout to prevent hanging on slow/unreachable URLs
- Cache verification results to avoid re-verifying same URLs
- Consider making it optional to avoid blocking workflow

**Alternative Approaches:**
1. **Client-Side Only Verification:**
   - Use CORS-enabled fetch requests from browser
   - Limited by CORS policies
   - May not work for all URLs

2. **Backend Verification Service:**
   - Create dedicated endpoint for URL verification
   - Backend makes HTTP requests (no CORS issues)
   - Can batch verify multiple URLs
   - Better for production use

3. **Progressive Verification:**
   - Verify URLs in background after CSV upload
   - Show warnings as verification completes
   - Don't block user workflow

**Related Files:**
- `backend/src/services/productParsingService.ts` - Product parsing service with URL validation (lines 27-34, 60-72)
- `src/services/validationService.ts` - Frontend validation service (lines 105-118)
- `src/components/csv-upload/CSVUploadScreen.tsx` - CSV upload screen component
- `src/components/csv-upload/ProductPreview.tsx` - Product preview with URL display

**Testing Considerations:**
- Test with valid, reachable URLs
- Test with invalid URLs (404, broken links)
- Test with unreachable URLs (wrong domain, network errors)
- Test with URLs that timeout
- Test with many URLs (performance)
- Test verification timeout handling
- Test with CORS-restricted URLs
- Test optional verification toggle
- Test user experience with verification delays
- Test error handling for network failures

**Known Limitations:**
- URL verification requires network requests and can be slow
- Some URLs may be behind authentication or firewalls
- CORS policies may prevent client-side verification
- Rate limiting may be needed for many URLs
- False positives/negatives possible (temporary network issues)

---

### BUG-006: Campaign Preview Pages Should Match Dashboard/Details Layout with PREVIEW Badge

**Priority:** üü° Medium  
**Category:** UI/UX  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Campaign Preview / Campaign Details  
**Estimated Fix Time:** 2-3 hours

**Description:**
The campaign preview pages (`/campaigns/preview`) and individual product campaign previews have a different layout and structure than the campaign dashboard and actual campaign details pages. This creates inconsistency in the user experience and makes it difficult to navigate between preview and actual campaigns. Additionally, actual campaign details pages do not show the detailed table view (ad groups, keywords, ads) that is available in the preview pages. The preview pages should match the dashboard/details layout with clear PREVIEW badges, and actual campaigns should be able to view all the information from preview pages.

**Steps to Reproduce:**
1. Navigate to `/campaigns/preview` after generating campaigns
2. Observe the current layout (dropdown selector, table view)
3. Navigate to `/campaigns` (dashboard) and observe the layout (campaign cards, filters)
4. Navigate to `/campaign/:id` (campaign details) and observe the layout (overview card, status, information)
5. Expected: Preview page should look like dashboard with tabs for easy access, individual previews should look like details page, and actual campaigns should show the detailed table view
6. Actual: Preview page has different layout, individual previews don't match details page, and actual campaigns don't show detailed table view

**Impact:**
- Inconsistent user experience between preview and actual campaigns
- Difficult navigation between preview and actual campaign views
- Missing information in actual campaign details (detailed table view with ad groups, keywords, ads)
- Users cannot easily switch between multiple preview campaigns
- Preview pages don't clearly indicate they are previews (no PREVIEW badge)
- Actual campaigns cannot view the same detailed information available in preview

**Current Implementation:**
1. **`/campaigns/preview` (CampaignPreviewScreen.tsx):**
   - Shows a dropdown selector for campaigns (if multiple)
   - Displays a single campaign preview table
   - Has validation summary and export functionality
   - Does NOT have tabs for easy navigation between campaigns
   - Does NOT match the dashboard layout

2. **Individual Campaign Preview:**
   - Shows campaign preview table with ad groups, keywords, and ads
   - Has filtering and sorting capabilities
   - Has inline editing capabilities
   - Does NOT match the campaign details page layout
   - Does NOT have PREVIEW badge

3. **`/campaign/:id` (CampaignDetail.tsx):**
   - Shows campaign overview card
   - Shows campaign status
   - Shows campaign information
   - Shows platform campaign IDs
   - Shows campaign actions
   - Does NOT show the detailed table view (ad groups, keywords, ads) from preview

**Root Cause:**
The preview pages were built with a different structure than the dashboard and details pages. The preview pages focus on editing and export functionality, while the dashboard and details pages focus on management and status. Additionally, the detailed table view component (CampaignPreviewTable) is only used in preview pages and not integrated into the actual campaign details page.

**Solution Approach:**

### Option 1: Refactor Preview Pages to Match Dashboard/Details Layout (Recommended)

**Implementation Strategy:**

1. **Refactor `/campaigns/preview` to Match Dashboard Layout:**
   - Replace dropdown selector with tabs (similar to dashboard campaign cards)
   - Show campaign cards in a grid layout (like dashboard)
   - Add PREVIEW badge to each campaign card
   - Add tabs for easy navigation between campaigns
   - Keep the preview table view when a campaign is selected
   - Add "Back to Dashboard" button

2. **Refactor Individual Campaign Preview to Match Details Page:**
   - Use the same layout structure as `CampaignDetail.tsx`
   - Show campaign overview card (with PREVIEW badge)
   - Show campaign status section (marked as PREVIEW)
   - Show campaign information section
   - Show the detailed table view (ad groups, keywords, ads) as a new section
   - Add PREVIEW badge prominently in the header
   - Keep inline editing and export functionality

3. **Add Detailed Table View to Actual Campaign Details:**
   - Add a new "Campaign Structure" or "Ad Groups & Ads" section to `CampaignDetail.tsx`
   - Reuse `CampaignPreviewTable` component (or create a read-only version)
   - Transform campaign data to `CampaignPreviewData` format
   - Show the table view with ad groups, keywords, and ads
   - Make it read-only (no editing) for actual campaigns
   - Add expand/collapse functionality for ad groups

4. **Add PREVIEW Badges:**
   - Add prominent PREVIEW badge to preview page header
   - Add PREVIEW badge to each campaign card in preview dashboard
   - Add PREVIEW badge to individual campaign preview header
   - Use consistent styling (e.g., yellow/orange badge with "PREVIEW" text)

**Recommended Implementation:**

```tsx
// In CampaignPreviewScreen.tsx, refactor to match dashboard layout:
const CampaignPreviewScreen: React.FC = () => {
  // ... existing code ...
  
  return (
    <div className="min-h-screen bg-background p-8">
      <div className="mx-auto max-w-7xl space-y-8">
        {/* Header with PREVIEW badge */}
        <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
          <div className="flex items-center gap-3">
            <h1 className="text-3xl font-bold tracking-tight">Campaign Preview</h1>
            <Badge variant="outline" className="bg-yellow-500/10 text-yellow-700 border-yellow-500/20">
              PREVIEW
            </Badge>
          </div>
          <Button variant="outline" onClick={handleBackToDashboard} type="button">
            <ArrowLeftIcon className="h-4 w-4" />
            Back to Dashboard
          </Button>
        </div>

        {/* Campaign Tabs (if multiple campaigns) */}
        {campaigns.length > 1 && (
          <Tabs value={selectedCampaign?.campaignId || ''} onValueChange={handleCampaignSelect}>
            <TabsList>
              {campaigns.map((campaign) => (
                <TabsTrigger key={campaign.id} value={campaign.id}>
                  {campaign.name}
                </TabsTrigger>
              ))}
            </TabsList>
          </Tabs>
        )}

        {/* Campaign Preview Content (matching details page layout) */}
        {selectedCampaign && (
          <div className="space-y-6">
            {/* Campaign Overview Card with PREVIEW badge */}
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <CardTitle>{selectedCampaign.campaignName}</CardTitle>
                  <Badge variant="outline" className="bg-yellow-500/10 text-yellow-700 border-yellow-500/20">
                    PREVIEW
                  </Badge>
                </div>
              </CardHeader>
              <CardContent>
                {/* Campaign overview information */}
              </CardContent>
            </Card>

            {/* Detailed Table View */}
            <CampaignPreviewTable previewData={selectedCampaign} />
          </div>
        )}
      </div>
    </div>
  );
};

// In CampaignDetail.tsx, add detailed table view:
const CampaignDetail: React.FC = () => {
  // ... existing code ...
  
  // Transform campaign to preview data format
  const previewData = useMemo(() => {
    if (!campaign?.campaignPlan) return null;
    // Transform campaign.campaignPlan to CampaignPreviewData format
    return transformCampaignToPreviewData(campaign);
  }, [campaign]);

  return (
    <div className="min-h-screen bg-background p-8">
      <div className="mx-auto max-w-7xl space-y-6">
        {/* ... existing header and overview sections ... */}

        {/* New: Campaign Structure Section */}
        {previewData && (
          <Card>
            <CardHeader>
              <CardTitle>Campaign Structure</CardTitle>
              <CardDescription>
                View ad groups, keywords, and ads for this campaign
              </CardDescription>
            </CardHeader>
            <CardContent>
              <CampaignPreviewTable 
                previewData={previewData} 
                readOnly={true} // Read-only for actual campaigns
              />
            </CardContent>
          </Card>
        )}

        {/* ... existing sections ... */}
      </div>
    </div>
  );
};
```

**Alternative Approaches:**

1. **Create Shared Layout Component:**
   - Create a shared `CampaignLayout` component
   - Use it for both preview and actual campaign pages
   - Pass `isPreview` prop to show/hide PREVIEW badges
   - Pass `readOnly` prop to enable/disable editing

2. **Create Read-Only Table Component:**
   - Create `CampaignStructureTable` component (read-only version)
   - Use it in actual campaign details page
   - Keep `CampaignPreviewTable` for preview pages (with editing)

3. **Add Tabs to Preview Screen:**
   - Use Tabs component from shadcn/ui
   - Show one tab per campaign
   - Allow easy switching between campaigns
   - Keep the table view in each tab

**Performance Considerations:**
- Transforming campaign data to preview format may be expensive
- Consider memoizing the transformation
- Lazy load the detailed table view if it's large
- Consider pagination for campaigns with many ad groups

**Related Files:**
- `src/components/campaign-preview/CampaignPreviewScreen.tsx` - Main preview screen (lines 1-311)
- `src/components/campaign-preview/CampaignPreviewTable.tsx` - Preview table component (lines 1-217)
- `src/components/CampaignDashboard.tsx` - Campaign dashboard (lines 1-477)
- `src/components/CampaignDetail.tsx` - Campaign details page (lines 1-363)
- `src/components/CampaignOverviewCard.tsx` - Campaign overview card component
- `src/types/campaign-preview.types.ts` - Preview data types

**Testing Considerations:**
- Test preview page with single campaign
- Test preview page with multiple campaigns (tabs)
- Test individual campaign preview layout
- Test PREVIEW badges are visible and consistent
- Test actual campaign details page with detailed table view
- Test navigation between preview and actual campaigns
- Test that preview editing works correctly
- Test that actual campaign table view is read-only
- Test responsive layout on different screen sizes
- Test that all information from preview is available in actual campaigns

**Known Limitations:**
- Preview pages may need significant refactoring
- May require updating multiple components
- Need to ensure data transformation works correctly
- May need to handle edge cases (campaigns without ad groups, etc.)

---

### BUG-007: Campaign Dashboard Enhancement: Hashtags, Tag Filtering, and Batch Actions

**Priority:** üü° Medium  
**Category:** UI/UX, Data Management  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Campaign Dashboard / Campaign Management  
**Estimated Fix Time:** 3-5 hours

**Description:**
The Campaign Dashboard currently lacks features for advanced campaign organization and bulk management. While the campaign data model already supports tags via `metadata.tags`, there is no UI to add, edit, or filter by tags. Additionally, there are no batch action capabilities to perform operations on multiple campaigns simultaneously. This enhancement addresses three key areas:
1. **Hashtags for Campaigns:** Users should be able to easily add and manage hashtags on campaigns.
2. **Filter by Tags:** A new filter option is needed on the dashboard to filter campaigns based on these hashtags.
3. **Batch Action Buttons:** Functionality to perform batch actions (e.g., delete all campaigns in a filtered group) should be available next to the tag filter.

**Steps to Reproduce:**
1. Navigate to the Campaign Dashboard (`/campaigns`)
2. Observe that there is no UI element to add hashtags to existing campaigns
3. Observe that the filter section only allows filtering by status, with no option to filter by tags
4. Observe that there are no batch action buttons available to perform operations on multiple campaigns simultaneously
5. Expected: Users should be able to add tags to campaigns, filter by tags, and perform batch actions on filtered campaigns
6. Actual: No tag management, tag filtering, or batch action functionality exists

**Impact:**
- **Poor Organization:** Users cannot categorize or group campaigns beyond their basic status
- **Difficult Searchability:** Difficult to find specific campaigns in a large list without tag-based filtering
- **Inefficient Management:** No way to perform bulk operations (like deletion) on multiple campaigns, requiring manual, individual actions
- **Underutilized Data Model:** The `metadata.tags` field exists in the data model but is not accessible through the UI

**Current Implementation:**
1. **Campaign Data Model:**
   - `Campaign` interface includes `metadata?: CampaignMetadata`
   - `CampaignMetadata` interface includes `tags?: string[]`
   - Backend also supports tags in campaign metadata
   - Tags are stored but not displayed or editable in the UI

2. **Campaign Dashboard (`CampaignDashboard.tsx`):**
   - Only filters by status (All, Draft, Active)
   - Shows campaign cards with basic information (name, status, platforms, budget, created date)
   - Individual delete button per campaign card
   - No tag display, tag input, or tag filtering
   - No batch action functionality

3. **Campaign Store:**
   - `useCampaignStore` manages campaign state
   - `updateCampaign` function exists but may need to handle metadata updates
   - No specific tag management functions

**Root Cause:**
The campaign data model supports tags, but the UI components were not built to expose or manage this functionality. The dashboard was designed with only status-based filtering and individual campaign actions, without considering tag-based organization or batch operations.

**Solution Approach:**

### Option 1: Complete Dashboard Enhancement (Recommended)

**Implementation Strategy:**

1. **Add Tag Input/Display to Campaign Cards:**
   - Add a tag input field or "Add Tag" button to each campaign card
   - Display existing tags as clickable badges on the campaign card
   - Allow inline editing of tags (add/remove)
   - Use a tag input component (e.g., multi-select with autocomplete)
   - Update campaign metadata when tags are added/removed

2. **Add "Filter by Tags" Component:**
   - Add a new filter section next to "Filter by status" in the filter card
   - Create a multi-select dropdown or tag selector component
   - Show all unique tags from all campaigns
   - Allow filtering by one or more tags
   - Combine tag filter with status filter (AND logic)
   - Show count of campaigns matching selected tags

3. **Add Batch Action Buttons:**
   - Add a batch actions container next to the tag filter
   - Add "Delete All Filtered" button (destructive action)
   - Show count of campaigns that will be affected
   - Implement confirmation dialog for batch delete
   - Add loading state during batch operations
   - Show success/error messages after batch operations

4. **Update Campaign Store:**
   - Ensure `updateCampaign` properly handles metadata updates
   - Add helper functions for tag management if needed
   - Update IndexedDB schema if necessary

5. **Backend API Updates (if needed):**
   - Ensure campaign update endpoint supports metadata updates
   - Add batch delete endpoint if not exists
   - Support filtering by tags in campaign queries

**Recommended Implementation:**

```tsx
// In CampaignDashboard.tsx, add tag state and filtering:
const CampaignDashboard: React.FC = () => {
  // ... existing state ...
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [showBatchDeleteConfirm, setShowBatchDeleteConfirm] = useState(false);

  // Get all unique tags from campaigns
  const allTags = useMemo(() => {
    const tagSet = new Set<string>();
    campaigns.forEach(campaign => {
      campaign.metadata?.tags?.forEach(tag => tagSet.add(tag));
    });
    return Array.from(tagSet).sort();
  }, [campaigns]);

  // Filter campaigns by status AND tags
  const filteredCampaigns = useMemo(() => {
    let filtered = campaigns;
    
    // Filter by status
    if (statusFilter !== 'all') {
      filtered = filtered.filter(c => c.status === statusFilter);
    }
    
    // Filter by tags
    if (selectedTags.length > 0) {
      filtered = filtered.filter(campaign => {
        const campaignTags = campaign.metadata?.tags || [];
        return selectedTags.every(tag => campaignTags.includes(tag));
      });
    }
    
    return filtered;
  }, [campaigns, statusFilter, selectedTags]);

  // Handle tag update for a campaign
  const handleTagUpdate = async (campaignId: string, tags: string[]) => {
    try {
      await campaignService.updateCampaign(campaignId, {
        metadata: { tags }
      });
      updateCampaignStore(campaignId, {
        metadata: { tags }
      });
      toastService.success('Tags updated successfully');
    } catch (error) {
      toastService.error('Failed to update tags');
    }
  };

  // Handle batch delete
  const handleBatchDelete = async () => {
    try {
      const campaignIds = filteredCampaigns.map(c => c.id);
      // Delete campaigns in parallel
      await Promise.all(
        campaignIds.map(id => campaignService.deleteCampaign(id))
      );
      // Remove from store
      campaignIds.forEach(id => removeCampaign(id));
      toastService.success(`Deleted ${campaignIds.length} campaigns`);
      setShowBatchDeleteConfirm(false);
      setSelectedTags([]);
      setStatusFilter('all');
    } catch (error) {
      toastService.error('Failed to delete campaigns');
    }
  };

  return (
    <div className="min-h-screen bg-background p-8">
      <div className="mx-auto max-w-7xl space-y-8">
        {/* ... existing header ... */}

        {/* Enhanced Filter Section */}
        {campaigns.length > 0 && (
          <Card>
            <CardContent className="pt-6">
              <div className="space-y-4">
                {/* Status Filter */}
                <div className="flex items-center gap-2 flex-wrap">
                  <FilterIcon className="h-4 w-4 text-muted-foreground" />
                  <span className="text-sm font-medium text-muted-foreground">Filter by status:</span>
                  <div className="flex gap-2 flex-wrap">
                    {/* ... existing status filter buttons ... */}
                  </div>
                </div>

                {/* Tag Filter */}
                <div className="flex items-center gap-2 flex-wrap">
                  <span className="text-sm font-medium text-muted-foreground">Filter by tags:</span>
                  <Select
                    value={selectedTags.join(',')}
                    onValueChange={(value) => setSelectedTags(value ? value.split(',') : [])}
                  >
                    <SelectTrigger className="w-[250px]">
                      <SelectValue placeholder="Select tags..." />
                    </SelectTrigger>
                    <SelectContent>
                      {allTags.map(tag => (
                        <SelectItem key={tag} value={tag}>
                          {tag} ({campaigns.filter(c => c.metadata?.tags?.includes(tag)).length})
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  {selectedTags.length > 0 && (
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => setSelectedTags([])}
                      type="button"
                    >
                      Clear tags
                    </Button>
                  )}
                </div>

                {/* Batch Actions */}
                {filteredCampaigns.length > 0 && (
                  <div className="flex items-center gap-2 flex-wrap border-t pt-4">
                    <span className="text-sm font-medium text-muted-foreground">
                      Batch actions ({filteredCampaigns.length} campaigns):
                    </span>
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => setShowBatchDeleteConfirm(true)}
                      type="button"
                    >
                      <TrashIcon className="h-4 w-4" />
                      Delete All Filtered
                    </Button>
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        )}

        {/* Campaign Cards with Tags */}
        {filteredCampaigns.map((campaign) => (
          <Card key={campaign.id}>
            {/* ... existing card content ... */}
            
            {/* Add Tags Section */}
            <CardContent>
              <div className="space-y-2">
                <div className="flex items-center gap-2 flex-wrap">
                  <span className="text-sm font-medium">Tags:</span>
                  {campaign.metadata?.tags?.map(tag => (
                    <Badge key={tag} variant="secondary">
                      {tag}
                      <button
                        onClick={() => {
                          const newTags = campaign.metadata?.tags?.filter(t => t !== tag) || [];
                          handleTagUpdate(campaign.id, newTags);
                        }}
                        className="ml-1"
                      >
                        √É‚Äî
                      </button>
                    </Badge>
                  ))}
                  <TagInput
                    onAddTag={(tag) => {
                      const currentTags = campaign.metadata?.tags || [];
                      if (!currentTags.includes(tag)) {
                        handleTagUpdate(campaign.id, [...currentTags, tag]);
                      }
                    }}
                    existingTags={allTags}
                  />
                </div>
              </div>
            </CardContent>
          </Card>
        ))}

        {/* Batch Delete Confirmation Dialog */}
        <Dialog open={showBatchDeleteConfirm} onOpenChange={setShowBatchDeleteConfirm}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Delete All Filtered Campaigns?</DialogTitle>
              <DialogDescription>
                Are you sure you want to delete {filteredCampaigns.length} campaign(s)?
                This action cannot be undone.
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => setShowBatchDeleteConfirm(false)}>
                Cancel
              </Button>
              <Button variant="destructive" onClick={handleBatchDelete}>
                Delete All
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  );
};
```

**Alternative Approaches:**

1. **Tag Input Component:**
   - Create a reusable `TagInput` component
   - Support autocomplete from existing tags
   - Allow adding multiple tags at once
   - Support tag suggestions based on campaign name/content

2. **Multi-Select Tag Filter:**
   - Use a multi-select dropdown or checkbox list
   - Show tag counts next to each tag
   - Support "Select All" / "Deselect All" functionality

3. **Batch Selection:**
   - Add checkboxes to campaign cards
   - Allow manual selection of campaigns
   - Batch actions work on selected campaigns instead of filtered campaigns

**Performance Considerations:**
- Tag filtering should be efficient (useMemo for filtered campaigns)
- Batch delete should show progress for large operations
- Consider debouncing tag input for autocomplete
- Cache unique tags list to avoid recalculating

**Related Files:**
- `src/components/CampaignDashboard.tsx` - Main dashboard component (lines 1-477)
- `src/types/campaign.types.ts` - Campaign type definitions (includes `CampaignMetadata` with `tags`)
- `src/store/campaignStore.ts` - Campaign state management
- `src/services/campaignService.ts` - Campaign API service
- `backend/src/types/campaign.types.ts` - Backend campaign types (supports tags in metadata)

**Testing Considerations:**
- Test adding tags to campaigns
- Test removing tags from campaigns
- Test filtering by single tag
- Test filtering by multiple tags
- Test filtering by tags AND status
- Test batch delete with filtered campaigns
- Test batch delete confirmation dialog
- Test edge cases: campaigns with no tags, many tags, duplicate tags
- Test tag autocomplete/suggestions
- Test UI responsiveness with many tags
- Test that tags persist after page refresh

**Known Limitations:**
- Tags are case-sensitive (may want to normalize to lowercase)
- No tag validation (may want to restrict special characters)
- No tag hierarchy or categories
- Batch operations may be slow for many campaigns
- No undo functionality for batch delete

---

### BUG-008: Campaign Dashboard Should Filter by Product Category with Batch Actions

**Priority:** üü° Medium  
**Category:** UI/UX, Data Management  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Campaign Dashboard / Campaign Management  
**Estimated Fix Time:** 2-3 hours

**Description:**
The Campaign Dashboard currently only allows filtering by campaign status (All, Draft, Active). However, campaigns are generated from products that have categories, and this product category information is stored in the campaign data but is not accessible through the UI for filtering. Users should be able to filter campaigns by product category (e.g., "Motorcycles", "Electronics", "Clothing") and perform batch actions on filtered campaigns. This enhancement addresses two key areas:
1. **Filter by Product Category:** A new filter option is needed on the dashboard to filter campaigns based on the product category they were generated from.
2. **Batch Action Buttons:** Functionality to perform batch actions (e.g., delete all campaigns in a filtered category group) should be available next to the category filter.

**Steps to Reproduce:**
1. Navigate to the Campaign Dashboard (`/campaigns`)
2. Observe that campaigns are displayed (some generated from products with categories)
3. Observe that the filter section only allows filtering by status, with no option to filter by product category
4. Observe that there are no batch action buttons available to perform operations on multiple campaigns simultaneously
5. Expected: Users should be able to filter campaigns by product category and perform batch actions on filtered campaigns
6. Actual: No category filtering or batch action functionality exists

**Impact:**
- **Poor Organization:** Users cannot filter campaigns by product category, making it difficult to manage campaigns for specific product types
- **Difficult Searchability:** Difficult to find campaigns for specific product categories in a large list
- **Inefficient Management:** No way to perform bulk operations (like deletion) on campaigns for a specific product category, requiring manual, individual actions
- **Underutilized Data:** Product category information is stored in campaigns but not accessible through the UI

**Current Implementation:**
1. **Campaign Data Model:**
   - `Campaign` interface includes `campaignPlan: CampaignPlan`
   - `CampaignPlan` includes `targetAudience.demographics.interests` which stores product category as an array (e.g., `[product.category || 'general']`)
   - `Campaign` also includes `metadata.tags` which may contain product category (e.g., `[product.category || 'auto-generated']`)
   - Product category is stored but not easily accessible for filtering

2. **Campaign Generation (`CampaignGenerationScreen.tsx`):**
   - When campaigns are generated from products, product category is stored in two places:
     - `campaignPlan.targetAudience.demographics.interests: [product.category || 'general']`
     - `metadata.tags: [product.category || 'auto-generated']`
   - Product category information is available but not exposed in the dashboard

3. **Campaign Dashboard (`CampaignDashboard.tsx`):**
   - Only filters by status (All, Draft, Active)
   - Shows campaign cards with basic information (name, status, platforms, budget, created date)
   - Does NOT display product category
   - Does NOT filter by product category
   - No batch action functionality

**Root Cause:**
Product category information is stored in campaigns (in `campaignPlan.targetAudience.demographics.interests` and `metadata.tags`), but the dashboard UI was not built to extract and filter by this information. The dashboard was designed with only status-based filtering, without considering category-based organization or batch operations.

**Solution Approach:**

### Option 1: Extract Category from Campaign Data and Add Filter (Recommended)

**Implementation Strategy:**

1. **Extract Product Category from Campaigns:**
   - Create a helper function to extract product category from campaign data
   - Check `campaignPlan.targetAudience.demographics.interests` first (primary source)
   - Fall back to `metadata.tags` if interests is empty or doesn't contain category
   - Handle cases where category might not exist (default to "Uncategorized" or "General")

2. **Add "Filter by Category" Component:**
   - Add a new filter section next to "Filter by status" in the filter card
   - Create a dropdown or button group component for category selection
   - Extract all unique categories from all campaigns
   - Show count of campaigns per category
   - Allow filtering by one or more categories
   - Combine category filter with status filter (AND logic)
   - Show count of campaigns matching selected category

3. **Add Batch Action Buttons:**
   - Add batch actions container next to the category filter
   - Add "Delete All Filtered" button (destructive action)
   - Show count of campaigns that will be affected
   - Implement confirmation dialog for batch delete
   - Add loading state during batch operations
   - Show success/error messages after batch operations
   - Integrate with existing batch action functionality (if BUG-007 is implemented)

4. **Display Category on Campaign Cards:**
   - Optionally display product category as a badge on each campaign card
   - Helps users quickly identify campaign categories
   - Can be clickable to filter by that category

**Recommended Implementation:**

```tsx
// In CampaignDashboard.tsx, add category extraction and filtering:
const CampaignDashboard: React.FC = () => {
  // ... existing state ...
  const [categoryFilter, setCategoryFilter] = useState<string | 'all'>('all');
  const [showBatchDeleteConfirm, setShowBatchDeleteConfirm] = useState(false);

  // Helper function to extract product category from campaign
  const getCampaignCategory = (campaign: Campaign): string => {
    // Try to get from campaignPlan.targetAudience.demographics.interests
    const interests = campaign.campaignPlan?.targetAudience?.demographics?.interests;
    if (interests && interests.length > 0) {
      // Category is typically the first interest
      return interests[0];
    }
    
    // Fall back to metadata.tags
    const tags = campaign.metadata?.tags;
    if (tags && tags.length > 0) {
      // Check if any tag looks like a category (not 'auto-generated')
      const categoryTag = tags.find(tag => tag !== 'auto-generated' && tag !== 'general');
      if (categoryTag) {
        return categoryTag;
      }
    }
    
    // Default to 'Uncategorized' if no category found
    return 'Uncategorized';
  };

  // Get all unique categories from campaigns
  const allCategories = useMemo(() => {
    const categorySet = new Set<string>();
    campaigns.forEach(campaign => {
      const category = getCampaignCategory(campaign);
      categorySet.add(category);
    });
    return Array.from(categorySet).sort();
  }, [campaigns]);

  // Filter campaigns by status AND category
  const filteredCampaigns = useMemo(() => {
    let filtered = campaigns;
    
    // Filter by status
    if (statusFilter !== 'all') {
      filtered = filtered.filter(c => c.status === statusFilter);
    }
    
    // Filter by category
    if (categoryFilter !== 'all') {
      filtered = filtered.filter(campaign => {
        const campaignCategory = getCampaignCategory(campaign);
        return campaignCategory === categoryFilter;
      });
    }
    
    return filtered;
  }, [campaigns, statusFilter, categoryFilter]);

  // Get count of campaigns by category
  const getCategoryCount = (category: string) => {
    return campaigns.filter(campaign => getCampaignCategory(campaign) === category).length;
  };

  // Handle batch delete
  const handleBatchDelete = async () => {
    try {
      const campaignIds = filteredCampaigns.map(c => c.id);
      // Delete campaigns in parallel
      await Promise.all(
        campaignIds.map(id => campaignService.deleteCampaign(id))
      );
      // Remove from store
      campaignIds.forEach(id => removeCampaign(id));
      toastService.success(`Deleted ${campaignIds.length} campaigns`);
      setShowBatchDeleteConfirm(false);
      setCategoryFilter('all');
      setStatusFilter('all');
    } catch (error) {
      toastService.error('Failed to delete campaigns');
    }
  };

  return (
    <div className="min-h-screen bg-background p-8">
      <div className="mx-auto max-w-7xl space-y-8">
        {/* ... existing header ... */}

        {/* Enhanced Filter Section */}
        {campaigns.length > 0 && (
          <Card>
            <CardContent className="pt-6">
              <div className="space-y-4">
                {/* Status Filter */}
                <div className="flex items-center gap-2 flex-wrap">
                  <FilterIcon className="h-4 w-4 text-muted-foreground" />
                  <span className="text-sm font-medium text-muted-foreground">Filter by status:</span>
                  <div className="flex gap-2 flex-wrap">
                    {/* ... existing status filter buttons ... */}
                  </div>
                </div>

                {/* Category Filter */}
                <div className="flex items-center gap-2 flex-wrap">
                  <span className="text-sm font-medium text-muted-foreground">Filter by category:</span>
                  <div className="flex gap-2 flex-wrap">
                    <Button
                      variant={categoryFilter === 'all' ? 'default' : 'outline'}
                      size="sm"
                      onClick={() => setCategoryFilter('all')}
                      type="button"
                    >
                      All ({campaigns.length})
                    </Button>
                    {allCategories.map(category => (
                      <Button
                        key={category}
                        variant={categoryFilter === category ? 'default' : 'outline'}
                        size="sm"
                        onClick={() => setCategoryFilter(category)}
                        type="button"
                      >
                        {category} ({getCategoryCount(category)})
                      </Button>
                    ))}
                  </div>
                </div>

                {/* Batch Actions */}
                {filteredCampaigns.length > 0 && (
                  <div className="flex items-center gap-2 flex-wrap border-t pt-4">
                    <span className="text-sm font-medium text-muted-foreground">
                      Batch actions ({filteredCampaigns.length} campaigns):
                    </span>
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => setShowBatchDeleteConfirm(true)}
                      type="button"
                    >
                      <TrashIcon className="h-4 w-4" />
                      Delete All Filtered
                    </Button>
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        )}

        {/* Campaign Cards with Category Display */}
        {filteredCampaigns.map((campaign) => {
          const category = getCampaignCategory(campaign);
          return (
            <Card key={campaign.id}>
              {/* ... existing card content ... */}
              
              {/* Add Category Badge */}
              <CardHeader>
                <div className="flex items-start justify-between gap-4">
                  <CardTitle className="line-clamp-1">{campaign.name}</CardTitle>
                  <div className="flex gap-2">
                    <Badge variant="secondary" onClick={() => setCategoryFilter(category)}>
                      {category}
                    </Badge>
                    <Badge variant={getStatusVariant(campaign.status)}>
                      {getStatusLabel(campaign.status)}
                    </Badge>
                  </div>
                </div>
              </CardHeader>
            </Card>
          );
        })}

        {/* Batch Delete Confirmation Dialog */}
        <Dialog open={showBatchDeleteConfirm} onOpenChange={setShowBatchDeleteConfirm}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Delete All Filtered Campaigns?</DialogTitle>
              <DialogDescription>
                Are you sure you want to delete {filteredCampaigns.length} campaign(s)?
                {categoryFilter !== 'all' && ` (Category: ${categoryFilter})`}
                {statusFilter !== 'all' && ` (Status: ${getStatusLabel(statusFilter)})`}
                This action cannot be undone.
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => setShowBatchDeleteConfirm(false)}>
                Cancel
              </Button>
              <Button variant="destructive" onClick={handleBatchDelete}>
                Delete All
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  );
};
```

**Alternative Approaches:**

1. **Store Category in Metadata:**
   - Add `productCategory` field to `CampaignMetadata` interface
   - Store category explicitly when creating campaigns
   - Makes category extraction more reliable
   - Requires updating campaign creation logic

2. **Multi-Select Category Filter:**
   - Use a multi-select dropdown or checkbox list
   - Allow filtering by multiple categories at once
   - Show category counts next to each category
   - Support "Select All" / "Deselect All" functionality

3. **Category Badge Click to Filter:**
   - Make category badges on campaign cards clickable
   - Clicking a badge filters by that category
   - Provides intuitive filtering mechanism

**Performance Considerations:**
- Category extraction should be efficient (useMemo for filtered campaigns)
- Batch delete should show progress for large operations
- Cache category list to avoid recalculating
- Consider memoizing category extraction function

**Related Files:**
- `src/components/CampaignDashboard.tsx` - Main dashboard component (lines 1-477)
- `src/components/campaign-generation/CampaignGenerationScreen.tsx` - Campaign generation (stores category in campaign data, lines 164-215)
- `src/types/campaign.types.ts` - Campaign type definitions
- `src/types/product.types.ts` - Product type definitions (includes `category?: string`)
- `src/store/campaignStore.ts` - Campaign state management

**Testing Considerations:**
- Test filtering by single category
- Test filtering by category AND status
- Test batch delete with filtered campaigns
- Test batch delete confirmation dialog
- Test edge cases: campaigns with no category, multiple categories, undefined categories
- Test category extraction from different sources (interests vs tags)
- Test UI responsiveness with many categories
- Test that category filter works with status filter
- Test that batch actions work correctly with category filter

**Known Limitations:**
- Category extraction relies on data structure (interests or tags)
- Categories may be inconsistent if stored differently
- No category validation or normalization
- Batch operations may be slow for many campaigns
- No undo functionality for batch delete
- Category might not be available for older campaigns created before category storage was implemented

---

### BUG-009: Campaign Dashboard Filter Bar Should Remain Static While Scrolling

**Priority:** üü° Medium  
**Category:** UI/UX  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Campaign Dashboard / Filter Bar  
**Estimated Fix Time:** 30-45 minutes

**Description:**
The Campaign Dashboard filter bar (containing status filter buttons, category filter buttons, and batch action buttons) scrolls off-screen when users scroll through the campaign list. This makes it difficult to change filters or access batch actions while viewing campaigns, as users must scroll back to the top to access the filter controls. The filter bar should remain fixed/sticky at the top of the viewport while scrolling through campaigns, allowing users to change filters and perform batch actions at any time.

**Steps to Reproduce:**
1. Navigate to the Campaign Dashboard (`/campaigns`)
2. Verify that campaigns are displayed (enough to require scrolling)
3. Scroll down through the campaign list
4. Observe that the filter bar (status filter, category filter, batch actions) scrolls off-screen
5. Expected: Filter bar should remain visible at the top while scrolling
6. Actual: Filter bar scrolls off-screen with the content, requiring users to scroll back to the top to change filters

**Impact:**
- **Poor Usability:** Users cannot change filters or access batch actions while viewing campaigns
- **Inefficient Workflow:** Users must scroll back to the top to change filters, disrupting their workflow
- **Reduced Productivity:** Time wasted scrolling back and forth to access filter controls
- **Frustrating User Experience:** Common pattern in modern web applications is to keep filter bars sticky/fixed

**Current Implementation:**
1. **Campaign Dashboard (`CampaignDashboard.tsx`):**
   - Filter bar is a regular `Card` component (lines 273-308)
   - No sticky positioning applied
   - Filter bar is part of the normal document flow
   - Scrolls with the rest of the content

2. **Layout Structure:**
   - Main container: `<div className="min-h-screen bg-background p-8">`
   - Content container: `<div className="mx-auto max-w-7xl space-y-8">`
   - Filter bar: `<Card>` component with no positioning classes
   - Campaign list: Grid of campaign cards below the filter bar

3. **No Sticky Positioning:**
   - No `sticky` or `fixed` CSS classes applied to the filter bar
   - No z-index management for sticky elements
   - No background color to prevent content bleeding through

**Root Cause:**
The filter bar is implemented as a regular Card component in the normal document flow, without any sticky positioning. When the page content exceeds the viewport height, the filter bar scrolls off-screen along with the rest of the content.

**Solution Approach:**

### Option 1: CSS Sticky Positioning (Recommended)

**Implementation Strategy:**

1. **Apply Sticky Positioning to Filter Bar Card:**
   - Add `sticky top-0` classes to the filter bar Card
   - Add appropriate z-index to ensure it stays above scrolling content
   - Add background color to prevent content bleeding through
   - Add border/shadow for visual separation

2. **Account for Header:**
   - If there's a fixed header, adjust `top` value to account for header height
   - Use `top-[header-height]` or similar to position below header

3. **Ensure Proper Stacking:**
   - Set appropriate z-index (e.g., `z-10` or `z-20`)
   - Ensure filter bar appears above campaign cards but below modals/dialogs

4. **Visual Polish:**
   - Add subtle shadow or border when sticky
   - Ensure background color matches page background
   - Add smooth transition when becoming sticky

**Recommended Implementation:**

```tsx
// In CampaignDashboard.tsx, modify the filter bar Card:
{campaigns.length > 0 && (
  <Card className="sticky top-0 z-10 bg-background border-b shadow-sm">
    <CardContent className="pt-6">
      <div className="space-y-4">
        {/* Status Filter */}
        <div className="flex items-center gap-2 flex-wrap">
          <FilterIcon className="h-4 w-4 text-muted-foreground" />
          <span className="text-sm font-medium text-muted-foreground">Filter by status:</span>
          <div className="flex gap-2 flex-wrap">
            {/* ... existing status filter buttons ... */}
          </div>
        </div>

        {/* Category Filter (if implemented) */}
        <div className="flex items-center gap-2 flex-wrap">
          <span className="text-sm font-medium text-muted-foreground">Filter by category:</span>
          <div className="flex gap-2 flex-wrap">
            {/* ... category filter buttons ... */}
          </div>
        </div>

        {/* Tag Filter (if implemented) */}
        <div className="flex items-center gap-2 flex-wrap">
          <span className="text-sm font-medium text-muted-foreground">Filter by tags:</span>
          {/* ... tag filter component ... */}
        </div>

        {/* Batch Actions */}
        {filteredCampaigns.length > 0 && (
          <div className="flex items-center gap-2 flex-wrap border-t pt-4">
            <span className="text-sm font-medium text-muted-foreground">
              Batch actions ({filteredCampaigns.length} campaigns):
            </span>
            <Button
              variant="destructive"
              size="sm"
              onClick={() => setShowBatchDeleteConfirm(true)}
              type="button"
            >
              <TrashIcon className="h-4 w-4" />
              Delete All Filtered
            </Button>
          </div>
        )}
      </div>
    </CardContent>
  </Card>
)}
```

**Alternative Approaches:**

1. **Fixed Positioning:**
   - Use `fixed top-0` instead of `sticky`
   - Requires padding on content to prevent overlap
   - More complex but provides absolute positioning

2. **Separate Layout Structure:**
   - Split layout into fixed header section and scrollable content section
   - Use flexbox or grid to create fixed top section
   - More structural changes required

3. **Sticky Container:**
   - Wrap filter bar in a sticky container
   - Apply sticky to container rather than Card
   - Provides more control over sticky behavior

**Performance Considerations:**
- Sticky positioning is well-supported in modern browsers
- Minimal performance impact
- Consider using `will-change: transform` for smoother scrolling
- Test on mobile devices for touch scrolling behavior

**Related Files:**
- `src/components/CampaignDashboard.tsx` - Main dashboard component (filter bar at lines 273-308)
- `src/components/ui/card.tsx` - Card component (may need styling adjustments)

**Testing Considerations:**
- Test sticky behavior with many campaigns (requires scrolling)
- Test sticky behavior with different filter combinations
- Test on different screen sizes (mobile, tablet, desktop)
- Test with different viewport heights
- Test that filter bar doesn't overlap with header (if fixed header exists)
- Test that filter bar appears above campaign cards
- Test that filter bar doesn't interfere with modals/dialogs
- Test scrolling performance with sticky filter bar
- Test on different browsers (sticky positioning support)
- Test that filter bar remains functional when sticky

**Known Limitations:**
- Sticky positioning may not work in very old browsers (IE11 and below)
- May need to account for fixed header height if header is also sticky
- Filter bar height may vary based on number of filters (status, category, tags, batch actions)
- May need responsive adjustments for mobile devices

---

### BUG-010: Performance Dashboard Header Should Remain Static While Scrolling

**Priority:** üü° Medium  
**Category:** UI/UX  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Performance Dashboard / Header  
**Estimated Fix Time:** 30-45 minutes

**Description:**
The Performance Dashboard header section (containing the title "Performance Dashboard", time range selector, export CSV button, status indicators, and last updated timestamp) scrolls off-screen when users scroll through the performance metrics below. This makes it difficult to change the time range or export data while viewing performance metrics, as users must scroll back to the top to access these controls. The header section should remain fixed/sticky at the top of the viewport while scrolling through performance metrics, allowing users to change time range and export data at any time.

**Steps to Reproduce:**
1. Navigate to a campaign's Performance Dashboard (`/campaign/:id/performance`)
2. Verify that performance metrics are displayed (enough to require scrolling)
3. Scroll down through the performance metrics (summary cards, charts, goals)
4. Observe that the header section (title, time range selector, export button, status indicators) scrolls off-screen
5. Expected: Header section should remain visible at the top while scrolling
6. Actual: Header section scrolls off-screen with the content, requiring users to scroll back to the top to change time range or export data

**Impact:**
- **Poor Usability:** Users cannot change time range or export data while viewing performance metrics
- **Inefficient Workflow:** Users must scroll back to the top to change time range or export data, disrupting their workflow
- **Reduced Productivity:** Time wasted scrolling back and forth to access header controls
- **Frustrating User Experience:** Common pattern in modern web applications is to keep dashboard headers sticky/fixed

**Current Implementation:**
1. **Performance Dashboard (`PerformanceDashboard.tsx`):**
   - Header section is a regular `div` component (lines 188-237)
   - No sticky positioning applied
   - Header is part of the normal document flow
   - Scrolls with the rest of the content

2. **Layout Structure:**
   - Main container: `<div className="min-h-screen bg-background p-8">`
   - Content container: `<div className="mx-auto max-w-7xl space-y-6">`
   - Header section: `<div className="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">` (lines 189-203)
   - Status indicators: `<div className="flex flex-wrap items-center gap-3">` (lines 206-237)
   - Performance metrics: Summary cards, charts, goals below header

3. **No Sticky Positioning:**
   - No `sticky` or `fixed` CSS classes applied to the header section
   - No z-index management for sticky elements
   - No background color to prevent content bleeding through

**Root Cause:**
The header section is implemented as a regular div in the normal document flow, without any sticky positioning. When the page content exceeds the viewport height, the header scrolls off-screen along with the rest of the content.

**Solution Approach:**

### Option 1: CSS Sticky Positioning (Recommended)

**Implementation Strategy:**

1. **Apply Sticky Positioning to Header Section:**
   - Wrap header and status indicators in a sticky container
   - Add `sticky top-0` classes to the header container
   - Add appropriate z-index to ensure it stays above scrolling content
   - Add background color to prevent content bleeding through
   - Add border/shadow for visual separation

2. **Account for Fixed Header:**
   - If there's a fixed header (e.g., site header), adjust `top` value to account for header height
   - Use `top-[header-height]` or similar to position below header
   - Check if Header component is sticky (it uses `sticky top-0 z-[1000]`)

3. **Ensure Proper Stacking:**
   - Set appropriate z-index (e.g., `z-10` or `z-20`, below header's `z-[1000]`)
   - Ensure header appears above performance metrics but below modals/dialogs
   - Header component uses `z-[1000]`, so dashboard header should use lower z-index

4. **Visual Polish:**
   - Add subtle shadow or border when sticky
   - Ensure background color matches page background
   - Add smooth transition when becoming sticky

**Recommended Implementation:**

```tsx
// In PerformanceDashboard.tsx, modify the header section:
return (
  <div className="min-h-screen bg-background p-8">
    <div className="mx-auto max-w-7xl space-y-6">
      {/* Sticky Header Section */}
      <div className="sticky top-0 z-10 bg-background border-b shadow-sm pb-4 -mx-8 px-8">
        {/* Header */}
        <div className="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between pt-4">
          <h1 className="text-3xl font-bold tracking-tight">Performance Dashboard</h1>
          <div className="flex flex-wrap items-center gap-3">
            <TimeRangeSelector
              selectedRange={timeRange}
              onRangeChange={handleTimeRangeChange}
              showCustom={false}
            />
            <ExportButton
              metrics={metrics}
              timeSeries={timeSeries || undefined}
              campaignId={id}
            />
          </div>
        </div>

        {/* Status Indicators */}
        <div className="flex flex-wrap items-center gap-3 pt-4">
          {isOffline && (
            <Badge variant="destructive" className="flex items-center gap-1.5">
              <WifiOffIcon className="h-3 w-3" />
              Offline
            </Badge>
          )}
          {isCachedData && !isOffline && (
            <Badge variant="secondary" className="flex items-center gap-1.5">
              <HardDriveIcon className="h-3 w-3" />
              Cached Data
            </Badge>
          )}
          {lastUpdated && (
            <span className="text-sm text-muted-foreground">
              Last updated: {lastUpdated.toLocaleTimeString()}
            </span>
          )}
          <Button
            variant="ghost"
            size="icon"
            onClick={() => setPollingEnabled(!pollingEnabled)}
            type="button"
            title={pollingEnabled ? 'Disable auto-refresh' : 'Enable auto-refresh'}
          >
            {pollingEnabled ? (
              <PauseIcon className="h-4 w-4" />
            ) : (
              <PlayIcon className="h-4 w-4" />
            )}
          </Button>
        </div>
      </div>

      {/* Performance Metrics (scrollable content) */}
      <div className="space-y-6">
        {/* Metrics Summary Cards */}
        <section>
          <MetricsSummaryCards metrics={metrics} />
        </section>

        {/* Performance Charts */}
        {timeSeries && (
          <section>
            <PerformanceCharts timeSeries={timeSeries} />
          </section>
        )}

        {/* Performance vs Goals */}
        <section>
          <PerformanceVsGoals metrics={metrics} goals={goals} />
        </section>
      </div>

      {/* Refreshing Indicator */}
      {isLoading && metrics && (
        <div className="fixed bottom-4 right-4 flex items-center gap-2 rounded-md border bg-background p-3 shadow-lg">
          <Loader2Icon className="h-4 w-4 animate-spin" />
          <span className="text-sm">Refreshing data...</span>
        </div>
      )}
    </div>
  </div>
);
```

**Alternative Approaches:**

1. **Fixed Positioning:**
   - Use `fixed top-0` instead of `sticky`
   - Requires padding on content to prevent overlap
   - More complex but provides absolute positioning
   - Need to account for header height in content padding

2. **Separate Layout Structure:**
   - Split layout into fixed header section and scrollable content section
   - Use flexbox or grid to create fixed top section
   - More structural changes required

3. **Sticky Container:**
   - Wrap header and status indicators in a sticky container
   - Apply sticky to container rather than individual elements
   - Provides more control over sticky behavior

**Performance Considerations:**
- Sticky positioning is well-supported in modern browsers
- Minimal performance impact
- Consider using `will-change: transform` for smoother scrolling
- Test on mobile devices for touch scrolling behavior

**Related Files:**
- `src/components/PerformanceDashboard.tsx` - Main performance dashboard component (header at lines 188-237)
- `src/components/layout/Header.tsx` - Site header component (uses `sticky top-0 z-[1000]`)

**Testing Considerations:**
- Test sticky behavior with many performance metrics (requires scrolling)
- Test sticky behavior with different time ranges
- Test on different screen sizes (mobile, tablet, desktop)
- Test with different viewport heights
- Test that header doesn't overlap with site header (if fixed header exists)
- Test that header appears above performance metrics
- Test that header doesn't interfere with modals/dialogs
- Test scrolling performance with sticky header
- Test on different browsers (sticky positioning support)
- Test that header remains functional when sticky (time range selector, export button)
- Test that status indicators remain visible when sticky

**Known Limitations:**
- Sticky positioning may not work in very old browsers (IE11 and below)
- May need to account for fixed site header height if header is also sticky
- Header height may vary based on content (status indicators, error messages)
- May need responsive adjustments for mobile devices
- Error messages in header may affect sticky behavior

---

### BUG-011: Performance Dashboard Export CSV Fails with "point.date.toISOString is not a function"

**Priority:** üü† High  
**Category:** Export, Data Processing  
**Status:** üü¢ Fixed  
**Discovered:** January 2025  
**Fixed:** November 9, 2025  
**Component:** Performance Dashboard / Export Button / Performance Service  
**Estimated Fix Time:** 30-60 minutes

**Description:**
When clicking the "Export CSV" button on the Performance Dashboard to export time series data, the application throws an error: "point.date.toISOString is not a function". This occurs because date values from the API are serialized as ISO strings (not Date objects) when received via axios, but the `exportToCSV` function in `performanceService.ts` assumes `point.date` is a Date object and calls `toISOString()` on it. When `point.date` is already a string, calling `toISOString()` fails, completely breaking the export functionality for time series data.

**Steps to Reproduce:**
1. Navigate to a campaign's Performance Dashboard (`/campaign/:id/performance`)
2. Verify that performance metrics and time series data are displayed
3. Click the "Export CSV" button in the header
4. Observe that an error message appears: "point.date.toISOString is not a function"
5. Expected: CSV file should download with time series data
6. Actual: Error is thrown and no CSV file is downloaded

**Impact:**
- **Broken Functionality:** Export CSV feature is completely broken for time series data
- **Data Loss Risk:** Users cannot export performance time series data for analysis
- **Poor User Experience:** Error message is displayed but export fails silently
- **Productivity Impact:** Users cannot export performance data for external analysis or reporting

**Current Implementation:**
1. **Performance Service (`performanceService.ts`):**
   - `exportToCSV` function at line 248-302
   - Line 259: `point.date.toISOString()` assumes `point.date` is a Date object
   - No type checking or conversion for date values
   - Directly calls `toISOString()` on `point.date`

2. **API Response Handling:**
   - When data comes from API via axios, dates are serialized as ISO strings
   - No date deserialization/transformation occurs in `getPerformance` or `getTimeSeries`
   - TypeScript types define `date: Date` but runtime values are strings

3. **Type Definition:**
   - `PerformanceDataPoint` interface defines `date: Date` (line 33 in `performance.types.ts`)
   - Runtime values from API are strings, not Date objects
   - Type mismatch between TypeScript types and actual runtime values

**Root Cause:**
When data is fetched from the API via axios, JSON serialization converts Date objects to ISO strings. The API response contains date values as strings (e.g., `"2025-01-06T00:00:00.000Z"`), but the code assumes they are Date objects and calls `toISOString()` on them. Since strings don't have a `toISOString()` method, the error is thrown.

**Solution Approach:**

### Option 1: Handle Both String and Date Types (Recommended)

**Implementation Strategy:**

1. **Add Type Checking in `exportToCSV`:**
   - Check if `point.date` is a string or Date object
   - If string, use it directly (it's already in ISO format)
   - If Date object, convert to ISO string
   - Handle both cases gracefully

2. **Normalize Date Values:**
   - Create a helper function to normalize date values
   - Convert strings to Date objects if needed, or use strings directly
   - Ensure consistent date format in CSV output

3. **Update Type Definitions (Optional):**
   - Consider updating types to reflect actual runtime values
   - Or add date transformation in API response handling

**Recommended Implementation:**

```typescript
// In performanceService.ts, modify the exportToCSV function:

exportToCSV(
  metrics: PerformanceMetrics | PerformanceDataPoint[],
  filename?: string
): void {
  let csvContent = '';
  let rows: string[][] = [];

  // Helper function to normalize date to ISO string
  const normalizeDate = (date: Date | string): string => {
    if (typeof date === 'string') {
      // Already an ISO string, return as-is or validate format
      return date;
    } else if (date instanceof Date) {
      // Date object, convert to ISO string
      return date.toISOString();
    } else {
      // Fallback: try to convert to Date and then to ISO string
      try {
        return new Date(date).toISOString();
      } catch {
        return String(date);
      }
    }
  };

  if (Array.isArray(metrics)) {
    // Time series data
    csvContent = 'Date,Impressions,Clicks,CTR,Conversions,CPA,ROAS,Spend,Revenue\n';
    rows = metrics.map((point) => [
      normalizeDate(point.date), // Use helper function instead of point.date.toISOString()
      point.impressions.toString(),
      point.clicks.toString(),
      point.ctr.toFixed(2),
      point.conversions.toString(),
      point.cpa.toFixed(2),
      point.roas.toFixed(2),
      point.spend.toFixed(2),
      point.revenue?.toFixed(2) || '0',
    ]);
  } else {
    // Single metrics object
    csvContent = 'Metric,Value\n';
    rows = [
      ['Impressions', metrics.impressions.toString()],
      ['Clicks', metrics.clicks.toString()],
      ['CTR', metrics.ctr.toFixed(2) + '%'],
      ['Conversions', metrics.conversions.toString()],
      ['CPA', metrics.cpa.toFixed(2)],
      ['ROAS', metrics.roas.toFixed(2)],
      ['Spend', metrics.spend.toFixed(2)],
      ['Revenue', metrics.revenue?.toFixed(2) || '0'],
      ['Start Date', normalizeDate(metrics.dateRange.start)],
      ['End Date', normalizeDate(metrics.dateRange.end)],
    ];
  }

  csvContent += rows.map((row) => row.join(',')).join('\n');

  // Create download link
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute(
    'download',
    filename ||
      `performance-${new Date().toISOString().split('T')[0]}.csv`
  );
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
```

**Alternative Approaches:**

1. **Transform Dates in API Response:**
   - Add date transformation in `getPerformance` and `getTimeSeries` methods
   - Convert string dates to Date objects when receiving API response
   - Ensures types match TypeScript definitions
   - More comprehensive but requires changes to multiple methods

2. **Update Type Definitions:**
   - Change `date: Date` to `date: Date | string` in `PerformanceDataPoint`
   - Reflect actual runtime values in types
   - Requires handling both types throughout codebase

3. **Use Date Parsing:**
   - Always parse date values as Date objects
   - Convert strings to Date objects before use
   - More consistent but may have performance overhead

**Performance Considerations:**
- Type checking is minimal overhead
- String comparison is fast
- Date parsing may have slight overhead if many data points
- Consider caching normalized dates if processing large datasets

**Related Files:**
- `src/services/performanceService.ts` - Export function at line 248-302 (line 259 is the problematic line)
- `src/types/performance.types.ts` - Type definitions (line 33 defines `date: Date`)
- `src/components/ExportButton.tsx` - Export button component that calls `exportToCSV`
- `src/components/PerformanceDashboard.tsx` - Performance dashboard that uses ExportButton

**Testing Considerations:**
- Test export with time series data where dates are strings
- Test export with time series data where dates are Date objects
- Test export with single metrics object (dateRange dates)
- Test export with empty time series data
- Test export with malformed date values
- Test export with different date formats
- Test export error handling and user feedback
- Test CSV file format and date formatting in exported file
- Test export with large datasets (performance)
- Test export on different browsers

**Known Limitations:**
- Date format in CSV will be ISO format (may want to customize)
- Timezone handling may need consideration
- Date parsing may fail with non-standard formats
- May need to handle null/undefined date values

---

### BUG-012: Inline Editing Behavior Issues in Campaign Preview

**Priority:** üü° Medium  
**Category:** UI/UX, Functionality  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Campaign Preview / Inline Editing  
**Estimated Fix Time:** 1-2 hours

**Description:**
The inline editing functionality in the Campaign Preview screen has several behavioral issues that affect user experience and workflow:

1. **Auto-save on blur:** Inline editing saves changes automatically when clicking off (onBlur event), instead of requiring an explicit "Accept Changes" or "Save" button. This can lead to accidental saves and makes it difficult to cancel changes.

2. **Edit activation by clicking text:** Inline editing is activated by clicking directly on the text/name (single click), instead of requiring activation via a dedicated "Edit" button. This makes it too easy to accidentally enter edit mode.

3. **Match type dropdown closes inline edit:** During inline editing of keywords, clicking the match type dropdown closes the inline edit state, preventing users from selecting a match type. The dropdown should remain functional within the inline edit state.

**Steps to Reproduce:**

**Issue 1: Auto-save on blur**
1. Navigate to Campaign Preview screen
2. Click on an ad group name or keyword text to enter edit mode
3. Make changes to the text
4. Click outside the input field (blur event)
5. Expected: Changes should not be saved automatically; should require explicit "Save" button
6. Actual: Changes are saved automatically on blur

**Issue 2: Edit activation by clicking text**
1. Navigate to Campaign Preview screen
2. Click directly on an ad group name or keyword text
3. Expected: Should not enter edit mode; should require clicking "Edit" button
4. Actual: Clicking text directly enters edit mode

**Issue 3: Match type dropdown closes inline edit**
1. Navigate to Campaign Preview screen
2. Click on a keyword to enter edit mode
3. Try to click on the match type dropdown
4. Expected: Dropdown should open and allow selection without closing edit mode
5. Actual: Clicking dropdown closes inline edit state, preventing match type selection

**Impact:**
- **Poor User Experience:** Accidental saves and difficulty canceling changes
- **Workflow Disruption:** Users cannot easily cancel edits or change match types
- **Data Integrity Risk:** Accidental saves may overwrite intended values
- **Frustrating Interaction:** Match type cannot be changed during keyword editing

**Current Implementation:**

1. **KeywordRow Component (`KeywordRow.tsx`):**
   - Line 115: `onBlur={handleSave}` - Saves automatically on blur
   - Line 130-136: Text is clickable button that sets `isEditing(true)` directly
   - Line 141-157: Match type Select component, but clicking it may trigger blur event

2. **AdGroupRow Component (`AdGroupRow.tsx`):**
   - Line 90: `onBlur={handleNameSave}` - Saves automatically on blur
   - Line 105-111: Ad group name is clickable button that sets `isEditing(true)` directly
   - Line 118-127: Edit button exists but clicking text also enables editing

3. **No explicit Save/Cancel buttons:**
   - No visible "Save" or "Cancel" buttons during inline editing
   - Only Enter key (save) and Escape key (cancel) are supported
   - No visual indication of edit state or pending changes

**Root Cause:**
1. **Auto-save on blur:** The `onBlur` event handler directly calls `handleSave()`, saving changes without user confirmation
2. **Click-to-edit:** Text elements are clickable buttons that directly set `isEditing(true)`, bypassing the edit button
3. **Dropdown interaction:** Clicking the Select dropdown trigger may trigger blur event on the input field, closing edit mode

**Solution Approach:**

### Option 1: Explicit Save/Cancel Buttons (Recommended)

**Implementation Strategy:**

1. **Remove auto-save on blur:**
   - Remove `onBlur={handleSave}` from input fields
   - Only save on explicit "Save" button click or Enter key
   - Add visual indication of unsaved changes

2. **Require Edit button activation:**
   - Remove click handlers from text elements
   - Only allow editing via dedicated "Edit" button (pencil icon)
   - Show edit button next to editable fields

3. **Fix match type dropdown:**
   - Prevent blur event from closing edit mode when clicking Select
   - Use `onOpenChange` or `onPointerDown` to prevent blur
   - Keep edit mode active while dropdown is open

4. **Add Save/Cancel buttons:**
   - Display "Save" and "Cancel" buttons when in edit mode
   - Replace edit button with save/cancel buttons during editing
   - Provide clear visual feedback for edit state

**Recommended Implementation:**

```tsx
// In KeywordRow.tsx, modify the edit mode:

{isEditing ? (
  <div className="space-y-1">
    <Input
      type="text"
      value={keywordText}
      onChange={(e) => {
        setKeywordText(e.target.value);
        setError(null);
      }}
      // Remove onBlur={handleSave}
      onKeyDown={(e) => {
        if (e.key === 'Enter') {
          handleSave();
        } else if (e.key === 'Escape') {
          handleCancel();
        }
      }}
      className={error ? 'border-destructive' : ''}
      autoFocus
      maxLength={80}
    />
    {error && <p className="text-xs text-destructive">{error}</p>}
    <div className="flex gap-2 mt-2">
      <Button size="sm" onClick={handleSave} type="button">
        Save
      </Button>
      <Button size="sm" variant="outline" onClick={handleCancel} type="button">
        Cancel
      </Button>
    </div>
  </div>
) : (
  <span className="text-left">{keywordText}</span>
)}

// In the Actions column, show edit button only when not editing:
<TableCell className="text-center">
  <div className="flex justify-center gap-1">
    {!isEditing && (
      <Button
        variant="ghost"
        size="sm"
        onClick={() => setIsEditing(true)}
        type="button"
        title="Edit"
        className="h-8 w-8 p-0"
      >
        <PencilIcon className="h-4 w-4" />
      </Button>
    )}
    <Button
      variant="ghost"
      size="sm"
      onClick={() => setShowDeleteDialog(true)}
      type="button"
      title="Delete"
      className="h-8 w-8 p-0 text-destructive hover:text-destructive"
    >
      <Trash2Icon className="h-4 w-4" />
    </Button>
  </div>
</TableCell>

// For match type dropdown, prevent blur:
<Select
  value={matchType}
  onValueChange={(value) => {
    setMatchType(value as 'broad' | 'phrase' | 'exact');
  }}
  onOpenChange={(open) => {
    // Prevent blur when dropdown opens
    if (open) {
      e?.stopPropagation();
    }
  }}
>
  <SelectTrigger 
    className="w-[120px]"
    onPointerDown={(e) => {
      // Prevent blur event
      e.stopPropagation();
    }}
  >
    <SelectValue />
  </SelectTrigger>
  <SelectContent>
    <SelectItem value="broad">Broad</SelectItem>
    <SelectItem value="phrase">Phrase</SelectItem>
    <SelectItem value="exact">Exact</SelectItem>
  </SelectContent>
</Select>
```

**Alternative Approaches:**

1. **Confirmation dialog on blur:**
   - Show confirmation dialog when clicking outside with unsaved changes
   - Ask user to save or discard changes
   - More complex but provides safety net

2. **Draft state:**
   - Keep changes in draft state until explicit save
   - Show visual indicator for unsaved changes
   - Allow multiple edits before saving

3. **Separate edit mode:**
   - Enter full edit mode for entire row
   - Edit all fields at once
   - Save all changes together

**Performance Considerations:**
- Adding Save/Cancel buttons has minimal performance impact
- Preventing blur events may require event handling adjustments
- Visual feedback should be immediate and clear

**Related Files:**
- `src/components/campaign-preview/KeywordRow.tsx` - Keyword inline editing (lines 106-137, 139-162)
- `src/components/campaign-preview/AdGroupRow.tsx` - Ad group name inline editing (lines 84-112)
- `src/components/campaign-preview/AdCopyEditor.tsx` - Ad copy editing (may have similar issues)

**Testing Considerations:**
- Test that clicking text does not enter edit mode
- Test that only Edit button activates edit mode
- Test that Save button saves changes
- Test that Cancel button discards changes
- Test that match type dropdown works during edit mode
- Test that blur event does not save changes
- Test Enter key saves changes
- Test Escape key cancels changes
- Test visual feedback for edit state
- Test multiple edits before saving

**Known Limitations:**
- May need to handle keyboard navigation (Tab key)
- May need to handle focus management
- May need to handle mobile touch events
- May need to handle accessibility (ARIA labels)

---

### BUG-013: RSA Ad Headlines Display Not Optimized in Campaign Preview

**Priority:** üü° Medium  
**Category:** UI/UX  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Campaign Preview / RSA Ad Display  
**Estimated Fix Time:** 1-2 hours

**Description:**
RSA Ad headlines are displayed in a vertical list of input fields within the expanded ad row, which appears less structured and visually organized compared to the keyword display in the Ad Group section. The keywords are displayed in a clean table format with badges and organized columns, while the RSA Ad headlines are shown as a simple vertical list of text inputs, making it harder to quickly review and compare multiple headlines. The display lacks visual hierarchy and organization compared to the keyword section.

**Steps to Reproduce:**
1. Navigate to Campaign Preview screen
2. Expand an ad group to see keywords and ads
3. Observe the keyword display (organized table format with badges)
4. Expand an RSA Ad row
5. Observe the headlines display (vertical list of input fields)
6. Expected: Headlines should be displayed in a more organized, visually appealing format similar to keywords
7. Actual: Headlines are displayed as a simple vertical list, less structured than keywords

**Impact:**
- **Poor Visual Hierarchy:** Headlines are harder to scan and compare
- **Inconsistent UI:** Different display styles between keywords and headlines
- **Reduced Usability:** More difficult to quickly review multiple headlines
- **Less Professional Appearance:** Inconsistent design reduces perceived quality

**Current Implementation:**

1. **AdCopyEditor Component (`AdCopyEditor.tsx`):**
   - Lines 143-178: Headlines are displayed in a vertical list
   - Each headline is a separate input field with character count
   - No table structure or organized layout
   - Simple div-based layout with minimal styling

2. **AdRow Component (`AdRow.tsx`):**
   - Expands to show AdCopyEditor component
   - No structured display for ad content

3. **Keyword Display:**
   - Keywords are displayed in table rows with badges
   - Organized columns (Type, Name/Text, Match Type, Actions)
   - Clean, structured appearance

**Root Cause:**
The RSA Ad headlines are rendered using a simple div-based layout with individual input fields, while keywords are displayed in a structured table format. The AdCopyEditor component uses a basic list structure without the visual organization of the keyword table.

**Solution Approach:**

### Option 1: Table-Based Display for Headlines (Recommended)

**Implementation Strategy:**

1. **Refactor AdCopyEditor to use table structure:**
   - Display headlines in a table format similar to keywords
   - Use TableRow and TableCell components for consistency
   - Add badges or visual indicators for headlines

2. **Create headline rows:**
   - Each headline as a table row
   - Columns: Type (badge), Headline Text (editable), Character Count, Actions
   - Match the visual style of keyword rows

3. **Maintain editability:**
   - Keep inline editing functionality
   - Use same edit pattern as keywords (Edit button, Save/Cancel)
   - Preserve character count and validation

4. **Visual consistency:**
   - Match styling with keyword rows
   - Use same badge styles and colors
   - Maintain same spacing and layout

**Recommended Implementation:**

```tsx
// In AdCopyEditor.tsx, refactor headlines section:

<div className="ad-section">
  <div className="section-header">
    <h4>Headlines ({ad.headlines.length}/15)</h4>
    {ad.headlines.length < 15 && (
      <Button size="sm" onClick={handleAddHeadline} type="button">
        + Add Headline
      </Button>
    )}
  </div>
  <div className="overflow-x-auto">
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Type</TableHead>
          <TableHead>Headline</TableHead>
          <TableHead className="text-center">Characters</TableHead>
          <TableHead className="text-center">Actions</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {ad.headlines.map((headline, index) => (
          <TableRow key={index}>
            <TableCell>
              <Badge variant="secondary">Headline</Badge>
            </TableCell>
            <TableCell>
              {editingHeadlineIndex === index ? (
                <div className="space-y-1">
                  <Input
                    type="text"
                    value={headline.text}
                    maxLength={30}
                    onChange={(e) => handleHeadlineChange(index, e.target.value)}
                    className={headlineErrors[index] ? 'border-destructive' : ''}
                    autoFocus
                  />
                  {headlineErrors[index] && (
                    <p className="text-xs text-destructive">{headlineErrors[index]}</p>
                  )}
                  <div className="flex gap-2 mt-2">
                    <Button size="sm" onClick={() => setEditingHeadlineIndex(null)} type="button">
                      Save
                    </Button>
                    <Button size="sm" variant="outline" onClick={() => setEditingHeadlineIndex(null)} type="button">
                      Cancel
                    </Button>
                  </div>
                </div>
              ) : (
                <span className="text-sm">{headline.text || `Headline ${index + 1}`}</span>
              )}
            </TableCell>
            <TableCell className="text-center">
              <span className={`text-xs ${headline.text.length > 30 ? 'text-destructive' : 'text-muted-foreground'}`}>
                {headline.text.length}/30
              </span>
            </TableCell>
            <TableCell className="text-center">
              <div className="flex justify-center gap-1">
                {editingHeadlineIndex !== index && (
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setEditingHeadlineIndex(index)}
                    type="button"
                    title="Edit"
                    className="h-8 w-8 p-0"
                  >
                    <PencilIcon className="h-4 w-4" />
                  </Button>
                )}
                {ad.headlines.length > 3 && (
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleDeleteHeadline(index)}
                    type="button"
                    title="Delete"
                    className="h-8 w-8 p-0 text-destructive hover:text-destructive"
                  >
                    <Trash2Icon className="h-4 w-4" />
                  </Button>
                )}
              </div>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  </div>
</div>
```

**Alternative Approaches:**

1. **Grid layout:**
   - Display headlines in a grid format
   - More compact but less structured
   - May be harder to scan

2. **Card-based layout:**
   - Each headline as a card
   - More visual separation
   - Less table-like but more modern

3. **Compact table:**
   - Smaller table with condensed rows
   - More headlines visible at once
   - May sacrifice readability

**Performance Considerations:**
- Table structure has minimal performance impact
- Rendering many headlines may require virtualization for large datasets
- Edit state management should be efficient

**Related Files:**
- `src/components/campaign-preview/AdCopyEditor.tsx` - RSA Ad headlines display (lines 143-178)
- `src/components/campaign-preview/AdRow.tsx` - Ad row component that contains AdCopyEditor
- `src/components/campaign-preview/KeywordRow.tsx` - Keyword row component (reference for table structure)

**Testing Considerations:**
- Test that headlines display in table format
- Test that table matches keyword table styling
- Test that editing still works in table format
- Test that character counts display correctly
- Test that add/delete functionality works
- Test with many headlines (15+)
- Test responsive design on mobile
- Test visual consistency with keywords

**Known Limitations:**
- May need to handle very long headlines (wrapping)
- May need responsive adjustments for mobile
- May need to consider accessibility (table semantics)

---

### BUG-014: Keyword Deletion Deletes Incorrect Item in Campaign Preview

**Priority:** üü† High  
**Category:** Functionality, Data Integrity  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Campaign Preview / Keyword Deletion  
**Estimated Fix Time:** 1-2 hours

**Description:**
When attempting to delete a keyword from the preview list, the item at the +1 position (the next item in the list) is deleted instead of the selected keyword. This is a critical data integrity issue that can lead to accidental deletion of the wrong keyword, potentially causing data loss and user frustration.

**Steps to Reproduce:**
1. Navigate to Campaign Preview screen
2. Expand an ad group to see keywords
3. Identify a specific keyword to delete (e.g., keyword at index 2)
4. Click the delete button (trash icon) on that keyword
5. Confirm deletion in the dialog
6. Expected: The selected keyword should be deleted
7. Actual: The keyword at the next position (index +1) is deleted instead

**Impact:**
- **Critical Data Integrity Issue:** Wrong keyword is deleted, causing data loss
- **User Frustration:** Users cannot reliably delete intended keywords
- **Workflow Disruption:** Users must work around the bug or manually correct deletions
- **Potential Data Loss:** Important keywords may be accidentally deleted

**Current Implementation:**

1. **KeywordRow Component (`KeywordRow.tsx`):**
   - Line 79-83: `handleDelete` function
   - Line 80: `keywordId = (keyword as any).id || keyword.text`
   - Line 81: `deleteKeyword(keywordId, adGroupId)`
   - Uses keyword text as ID if no ID exists

2. **Store Implementation (`campaignPreviewStore.ts`):**
   - Line 201-217: `deleteKeyword` function
   - Line 208-210: Filters keywords by `kw.text !== keywordId && (kw as any).id !== keywordId`
   - Uses text comparison for deletion

3. **Keyword Mapping (`AdGroupRow.tsx`):**
   - Line 132-138: Maps keywords with `key={`keyword-${adGroup.id}-${index}`}`
   - Uses index for React key, but keywordId may not match

**Root Cause:**
The issue likely stems from a mismatch between the keyword identifier used for deletion and the actual keyword being targeted. Possible causes:

1. **Index mismatch:** The `keywordIndex` prop is passed but not used in deletion logic
2. **ID mismatch:** Keywords may not have unique IDs, causing deletion to target wrong item
3. **Array filtering issue:** The filter logic may be removing the wrong item due to ID/text comparison
4. **React key issue:** Using index for React keys may cause component mismatch

**Solution Approach:**

### Option 1: Use Index-Based Deletion (Recommended)

**Implementation Strategy:**

1. **Pass index to delete handler:**
   - Use `keywordIndex` prop in deletion
   - Delete by array index instead of ID/text comparison
   - More reliable for array-based data

2. **Update store to use index:**
   - Modify `deleteKeyword` to accept index parameter
   - Use `splice` or filter by index instead of ID
   - Ensure correct item is removed

3. **Ensure unique keys:**
   - Use stable IDs for React keys if available
   - Or use index with stable identifier
   - Prevent React component mismatch

**Recommended Implementation:**

```tsx
// In KeywordRow.tsx, modify handleDelete:

const handleDelete = () => {
  // Use index-based deletion instead of ID-based
  deleteKeyword(adGroupId, keywordIndex);
  setShowDeleteDialog(false);
};

// In campaignPreviewStore.ts, modify deleteKeyword:

deleteKeyword: (adGroupId: string, keywordIndex: number) => {
  const state = get();
  if (!state.editedPreviewData) return;

  const updatedData = { ...state.editedPreviewData };
  const adGroupIndex = updatedData.adGroups.findIndex((ag) => ag.id === adGroupId);
  if (adGroupIndex !== -1) {
    // Use index-based deletion
    const keywords = [...updatedData.adGroups[adGroupIndex].keywords];
    if (keywordIndex >= 0 && keywordIndex < keywords.length) {
      keywords.splice(keywordIndex, 1);
      updatedData.adGroups[adGroupIndex].keywords = keywords;
      updatedData.totalKeywords = updatedData.adGroups.reduce((sum, ag) => sum + ag.keywords.length, 0);
      set({
        editedPreviewData: updatedData,
        hasUnsavedChanges: true,
      });
    }
  }
},
```

**Alternative Approaches:**

1. **Generate unique IDs:**
   - Assign unique IDs to all keywords
   - Use IDs for deletion instead of index
   - More robust but requires ID generation

2. **Use keyword object reference:**
   - Pass entire keyword object to delete
   - Compare by object reference
   - More reliable but requires object stability

3. **Use stable identifier:**
   - Create stable identifier from keyword text + index
   - Use for both React keys and deletion
   - Combines benefits of both approaches

**Performance Considerations:**
- Index-based deletion is O(1) for splice, O(n) for filter
- ID-based deletion requires O(n) search
- Minimal performance difference for typical keyword counts

**Related Files:**
- `src/components/campaign-preview/KeywordRow.tsx` - Keyword deletion handler (lines 79-83)
- `src/store/campaignPreviewStore.ts` - Delete keyword store function (lines 201-217)
- `src/components/campaign-preview/AdGroupRow.tsx` - Keyword mapping (lines 132-138)

**Testing Considerations:**
- Test deleting first keyword in list
- Test deleting last keyword in list
- Test deleting middle keyword
- Test deleting keyword with duplicate text
- Test deleting after adding new keyword
- Test deleting after editing keyword
- Test with multiple ad groups
- Test with many keywords (20+)
- Verify correct keyword is deleted
- Verify other keywords remain intact

**Known Limitations:**
- Index-based deletion may break if keywords are reordered
- May need to handle concurrent deletions
- May need to handle keyword addition during deletion

---

### BUG-015: Validation Errors Not Linked to Elements on Page in Campaign Preview

**Priority:** üü° Medium  
**Category:** UI/UX, Functionality  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Campaign Preview / Validation Summary  
**Estimated Fix Time:** 1-2 hours

**Description:**
When validation errors are found during campaign validation, they are displayed in the validation summary section at the top of the Campaign Preview screen. However, there is no indication of where on the page those errors actually are located. Users cannot navigate to or find the specific elements (ad groups, keywords, ads, headlines, descriptions) that have validation errors, making it difficult to fix the errors. The validation errors include `rowId` information that identifies the specific element, but this information is not used to link errors to their locations on the page.

**Steps to Reproduce:**
1. Navigate to Campaign Preview screen
2. Create or edit campaign data to introduce validation errors (e.g., empty headline, invalid URL, missing description)
3. Observe validation summary at top of screen showing errors
4. Expected: Errors should be clickable or linked to their locations on the page, allowing users to navigate to and fix them
5. Actual: Errors are displayed in a list format with field and message, but no way to navigate to the actual elements on the page

**Impact:**
- **Poor User Experience:** Users cannot easily find and fix validation errors
- **Workflow Disruption:** Users must manually search through the preview table to find error locations
- **Time Wasted:** Significant time spent locating errors instead of fixing them
- **Frustrating Interaction:** Common pattern in modern web applications is to link errors to their locations

**Current Implementation:**

1. **Validation Summary Display (`CampaignPreviewScreen.tsx`):**
   - Lines 214-260: Validation summary displays errors in a list format
   - Line 248-252: Errors are displayed with field and message
   - No clickable links or navigation to error locations
   - No visual indication of error locations in the preview table

2. **Validation Error Structure (`validationService.ts`):**
   - Lines 127-238: Validation errors include `rowId` field
   - `rowId` identifies specific elements (e.g., `adGroup.id`, `keyword-${adGroup.id}-${index}`, `ad-${adGroup.id}-${adIndex}-headline-${hIndex}`)
   - `rowId` information is available but not used for navigation

3. **Preview Table Components:**
   - No error highlighting or visual indicators for elements with errors
   - No data attributes or IDs matching validation error `rowId` values
   - No scroll-to or focus functionality for error locations

**Root Cause:**
The validation errors contain `rowId` information that identifies the specific elements, but this information is not used to:
1. Link errors to their locations in the preview table
2. Highlight or indicate error locations visually
3. Provide navigation (scroll-to or focus) to error locations
4. Match error `rowId` values with element IDs or data attributes

**Solution Approach:**

### Option 1: Clickable Error Links with Scroll-to (Recommended)

**Implementation Strategy:**

1. **Add data attributes to table elements:**
   - Add `data-row-id` attributes to ad group rows, keyword rows, ad rows
   - Match `rowId` values from validation errors
   - Enable element identification and navigation

2. **Make errors clickable:**
   - Convert error list items to clickable links or buttons
   - Add onClick handler to scroll to and highlight error location
   - Provide visual feedback when error is clicked

3. **Implement scroll-to functionality:**
   - Use `scrollIntoView()` to navigate to error location
   - Expand collapsed ad groups if needed
   - Highlight error element temporarily (e.g., border, background color)

4. **Visual error indicators:**
   - Add error badges or icons to elements with errors
   - Use error styling (red border, background) for error elements
   - Show error count or indicator in ad group/row headers

**Recommended Implementation:**

```tsx
// In CampaignPreviewScreen.tsx, modify error display:

{validationResult.errors.slice(0, 10).map((error, index) => (
  <li key={index} className="text-sm">
    <button
      onClick={() => {
        // Find element by rowId
        const element = document.querySelector(`[data-row-id="${error.rowId}"]`);
        if (element) {
          // Expand ad group if collapsed
          const adGroupRow = element.closest('[data-ad-group-id]');
          if (adGroupRow) {
            const toggleButton = adGroupRow.querySelector('[data-toggle]');
            if (toggleButton && !adGroupRow.classList.contains('expanded')) {
              toggleButton.click();
            }
          }
          // Scroll to element
          element.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Highlight element temporarily
          element.classList.add('error-highlight');
          setTimeout(() => {
            element.classList.remove('error-highlight');
          }, 3000);
        }
      }}
      className="text-left hover:text-primary hover:underline cursor-pointer"
      type="button"
    >
      <strong>{error.field}</strong>: {error.message}
    </button>
  </li>
))}

// In AdGroupRow.tsx, add data attribute:
<TableRow 
  className="bg-muted/50 hover:bg-muted/70"
  data-row-id={adGroup.id}
  data-ad-group-id={adGroup.id}
>

// In KeywordRow.tsx, add data attribute:
<TableRow 
  className="hover:bg-muted/50"
  data-row-id={`keyword-${adGroupId}-${keywordIndex}`}
>

// In AdRow.tsx, add data attribute:
<TableRow 
  className="hover:bg-muted/50"
  data-row-id={`ad-${adGroupId}-${adIndex}`}
>

// In AdCopyEditor.tsx, add data attributes to headlines/descriptions:
<div 
  className="headline-item"
  data-row-id={`ad-${adGroupId}-${adIndex}-headline-${index}`}
>
```

**Alternative Approaches:**

1. **Error badges on elements:**
   - Add error badges/icons directly on elements with errors
   - Show error count or indicator
   - Click badge to show error details

2. **Sidebar error list:**
   - Create sidebar with error list
   - Click error to navigate to location
   - Keep error list visible while scrolling

3. **Error highlighting:**
   - Automatically highlight all error elements
   - Use visual indicators (red border, background)
   - Show error tooltips on hover

**Performance Considerations:**
- Scroll-to functionality has minimal performance impact
- Element highlighting may require CSS transitions
- Data attributes have no performance overhead
- May need to handle many errors efficiently

**Related Files:**
- `src/components/campaign-preview/CampaignPreviewScreen.tsx` - Validation summary display (lines 214-260)
- `src/components/campaign-preview/CampaignPreviewTable.tsx` - Preview table component
- `src/components/campaign-preview/AdGroupRow.tsx` - Ad group row component
- `src/components/campaign-preview/KeywordRow.tsx` - Keyword row component
- `src/components/campaign-preview/AdRow.tsx` - Ad row component
- `src/components/campaign-preview/AdCopyEditor.tsx` - Ad copy editor component
- `src/services/validationService.ts` - Validation service (lines 123-238)

**Testing Considerations:**
- Test clicking error links navigates to correct location
- Test scroll-to functionality works for all error types
- Test expanding collapsed ad groups when navigating to errors
- Test error highlighting appears and disappears
- Test with many errors (10+)
- Test with errors in different ad groups
- Test with errors in collapsed ad groups
- Test with errors in expanded ad groups
- Test navigation to headline errors
- Test navigation to description errors
- Test navigation to keyword errors
- Test navigation to ad group errors
- Test responsive design on mobile

**Known Limitations:**
- May need to handle errors in collapsed sections
- May need to handle errors that are off-screen
- May need to handle multiple errors in same element
- May need to handle errors in nested elements (headlines, descriptions)

---

### BUG-016: Ad Group Name Display Not Updated After Inline Edit

**Priority:** üü° Medium  
**Category:** UI/UX, Functionality  
**Status:** üü¢ Fixed  
**Discovered:** January 2025  
**Fixed:** November 8, 2025  
**Component:** Campaign Preview / Ad Group Row  
**Estimated Fix Time:** 30-60 minutes

**Description:**
When editing an ad group name using inline editing in the Campaign Preview screen, the changes are saved to the store (as evidenced by the edited value appearing in the editor when reopened), but the displayed ad group name in the table does not update to reflect the changes. The component continues to display the original name from the prop instead of reading from the edited data in the store.

**Steps to Reproduce:**
1. Navigate to Campaign Preview screen
2. Click on an ad group name to enter inline edit mode
3. Edit the ad group name (e.g., change "Yamaha SR400" to "Yamaha SR400 - Updated")
4. Save the changes (click Save button or press Enter)
5. Observe that the displayed ad group name remains the same (original name)
6. Click on the ad group name again to enter edit mode
7. Observe that the edited value is shown in the input field (confirming it was saved)
8. Exit edit mode again
9. Observe that the displayed name still shows the original value

**Impact:**
- **Poor User Experience:** Users cannot see their changes reflected in the UI
- **Confusion:** Users may think their edits didn't save, even though they did
- **Data Integrity Concerns:** Users may re-edit thinking the first edit failed
- **Workflow Disruption:** Users must rely on export to verify their changes were saved

**Current Implementation:**

1. **AdGroupRow Component (`AdGroupRow.tsx`):**
   - Line 26: `const [editValue, setEditValue] = useState(adGroup.name);` - Initializes with prop value
   - Line 110: `{adGroup.name}` - Displays prop value directly, not from store
   - Line 43-45: `updateAdGroup(adGroupId, updates)` - Updates store correctly
   - Component doesn't read from `editedPreviewData` in store

2. **Campaign Preview Store (`campaignPreviewStore.ts`):**
   - Lines 71-90: `updateAdGroup` function updates `editedPreviewData` correctly
   - Store maintains edited data separately from original preview data
   - Store updates are working correctly

3. **Campaign Preview Table (`CampaignPreviewTable.tsx`):**
   - Line 30: `const { editedPreviewData } = useCampaignPreviewStore();`
   - Line 33: `const displayData = editedPreviewData || previewData;` - Uses edited data if available
   - Line 47: `let filtered = displayData.adGroups;` - Uses displayData for filtering/sorting
   - Table component correctly uses edited data, but AdGroupRow receives prop from table

**Root Cause:**
The `AdGroupRow` component receives `adGroup` as a prop from `CampaignPreviewTable`, which correctly uses `editedPreviewData` from the store. However, the `AdGroupRow` component:
1. Initializes local state with prop value on mount
2. Displays prop value directly instead of reading from store
3. Doesn't update when store changes (no useEffect to sync with store)
4. Doesn't use `editedPreviewData` from store directly

The component needs to either:
- Read from store directly instead of using prop
- Sync local state with store changes using useEffect
- Use the edited data from the store when available

**Solution Approach:**

**Recommended Fix: Read from Store in Component**

Modify `AdGroupRow.tsx` to read the current ad group data from the store instead of relying solely on the prop:

```typescript
// In AdGroupRow.tsx
const AdGroupRow: React.FC<AdGroupRowProps> = ({ adGroup, isExpanded, onToggle }) => {
  const { editedPreviewData } = useCampaignPreviewStore();
  
  // Get current ad group data from store if available, otherwise use prop
  const currentAdGroup = useMemo(() => {
    if (editedPreviewData) {
      const storeAdGroup = editedPreviewData.adGroups.find(ag => ag.id === adGroup.id);
      if (storeAdGroup) {
        return storeAdGroup;
      }
    }
    return adGroup;
  }, [editedPreviewData, adGroup]);
  
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(currentAdGroup.name);
  const [error, setError] = useState<string | null>(null);
  
  // Sync editValue when currentAdGroup.name changes
  useEffect(() => {
    setEditValue(currentAdGroup.name);
  }, [currentAdGroup.name]);
  
  // ... rest of component
  
  // Update display to use currentAdGroup.name instead of adGroup.name
  <button
    className="text-left hover:text-primary transition-colors font-medium"
    onClick={() => setIsEditing(true)}
    type="button"
  >
    {currentAdGroup.name}
  </button>
```

**Alternative Approach: Update Prop from Parent**

Ensure `CampaignPreviewTable` passes the edited ad group data to `AdGroupRow`:

```typescript
// In CampaignPreviewTable.tsx
{filteredAndSortedAdGroups.map((adGroup) => (
  <AdGroupRow
    key={adGroup.id}
    adGroup={adGroup} // This should already be from displayData (editedPreviewData || previewData)
    isExpanded={expandedAdGroups.has(adGroup.id)}
    onToggle={() => toggleAdGroup(adGroup.id)}
  />
))}
```

The issue is that `AdGroupRow` may be receiving stale prop data or not re-rendering when store updates.

**Performance Considerations:**
- Reading from store on each render has minimal performance impact
- useMemo prevents unnecessary recalculations
- useEffect only runs when name changes

**Related Files:**
- `src/components/campaign-preview/AdGroupRow.tsx` - Ad group row component (lines 24-153)
- `src/components/campaign-preview/CampaignPreviewTable.tsx` - Preview table component (lines 24-214)
- `src/store/campaignPreviewStore.ts` - Campaign preview store (lines 71-90)

**Testing Considerations:**
- Test ad group name edit and display update
- Test multiple ad group name edits
- Test edit, cancel, then edit again
- Test edit, save, then edit again
- Test with multiple ad groups
- Test with expanded/collapsed ad groups
- Verify edited name appears in export CSV

**Known Limitations:**
- May need to handle edge cases where store data is null
- May need to handle rapid successive edits
- May need to handle cancel after edit

**Fix Summary:**

‚úÖ **Fixed on November 8, 2025**

**Changes Made:**
1. **Read from Store in Component** (`AdGroupRow.tsx`):
   - Added `editedPreviewData` to `useCampaignPreviewStore` destructuring
   - Introduced `currentAdGroup` using `useMemo` to get the latest ad group data from `editedPreviewData` in the store, falling back to the `adGroup` prop if not found in the store
   - Initialized `editValue` state with `currentAdGroup.name`
   - Added `useEffect` hook to update `editValue` whenever `currentAdGroup.name` changes, ensuring the input field stays in sync
   - Updated the displayed ad group name to use `currentAdGroup.name` instead of `adGroup.name`
   - Updated `handleNameCancel` to reset `editValue` to `currentAdGroup.name`

2. **Component Updates:**
   - Added `useMemo` and `useEffect` imports from React
   - Component now reads from store directly instead of relying solely on prop
   - Display updates immediately when store changes

**Key Changes:**
- Read from `editedPreviewData` in store instead of prop
- Use `useMemo` to get current ad group data from store
- Use `useEffect` to sync `editValue` with `currentAdGroup.name`
- Display `currentAdGroup.name` instead of `adGroup.name`

**Result:**
- Ad group name display now updates immediately after inline editing
- Changes are reflected in the UI as soon as they're saved
- Component correctly reads from store's edited data
- No more confusion about whether edits were saved
- Display stays in sync with store state

**Testing Results:**
- ‚úÖ Ad group name display updates correctly after edit
- ‚úÖ Multiple edits work correctly
- ‚úÖ Edit, cancel, then edit again works correctly
- ‚úÖ Edit, save, then edit again works correctly
- ‚úÖ Works with multiple ad groups
- ‚úÖ Works with expanded/collapsed ad groups
- ‚úÖ Edited name appears correctly in export CSV

**Known Limitations:**
- Store data may be null in edge cases (handled with fallback to prop)
- Rapid successive edits are handled correctly
- Cancel after edit works correctly

---

### BUG-017: Export Validation Fails with Empty Errors Array

**Priority:** üü† High  
**Category:** Export, Validation  
**Status:** üü¢ Fixed  
**Discovered:** January 2025  
**Fixed:** November 8, 2025  
**Component:** Campaign Preview / Export Button  
**Estimated Fix Time:** 30-60 minutes

**Description:**
When attempting to export a campaign to Google Ads Editor CSV format, the export validation fails with a toast message "Export validation failed:" but no specific errors are shown. The browser console shows "Frontend validation failed: []" with an empty errors array. The validation fails even when the campaign data is valid and ready for export.

**Steps to Reproduce:**
1. Upload CSV with products and generate campaigns
2. Navigate to Campaign Preview screen
3. Verify campaign data is valid (no validation errors shown)
4. Click "Export to Google Ads Editor" button
5. Observe toast message "Export validation failed:" with no specific errors
6. Check browser console - shows "Frontend validation failed: []" (empty errors array)
7. Export is blocked even though data is valid

**Impact:**
- **Export Functionality Broken:** Users cannot export valid campaigns
- **Poor User Experience:** No specific error messages to help diagnose the issue
- **Workflow Blocking:** Critical feature (export) is completely non-functional
- **Confusing Error State:** Empty errors array suggests validation logic bug

**Current Implementation:**

1. **ExportButton Component (`ExportButton.tsx`):**
   - Line 31: Calls `validateCampaign()` from the store
   - Line 24: Uses `dataToExport = editedPreviewData || previewData` (has the data)
   - Line 31: But validates using store's `validateCampaign()` which checks store state

2. **Campaign Preview Store (`campaignPreviewStore.ts`):**
   - Lines 319-336: `validateCampaign()` function checks `state.editedPreviewData`
   - Line 321: If `editedPreviewData` is null, returns `isValid: false` with empty errors array
   - Doesn't check `previewData` as fallback
   - Doesn't accept data as parameter - only checks store's internal state

3. **Root Cause:**
   - ExportButton receives `previewData` as a prop and has `dataToExport` ready
   - But calls `validateCampaign()` from store, which checks store's state
   - Store's `editedPreviewData` and `previewData` may be null (not set in store)
   - Store validation returns `isValid: false` with empty errors when store data is null
   - Even though ExportButton has valid data to export

**Root Cause:**
The `ExportButton` component calls `validateCampaign()` from the store, which validates the store's internal state (`editedPreviewData` or `previewData`). However, the store may not have the preview data set (both are null), even though the `ExportButton` receives the data as a prop (`previewData`) and has `dataToExport` ready. The store's validation function doesn't accept data as a parameter and only checks its internal state, causing it to return `isValid: false` with an empty errors array when the store data is null.

**Solution Approach:**

**Recommended Fix: Validate Data Directly in ExportButton**

Update `ExportButton.tsx` to validate the actual data being exported instead of relying on the store's validation:

```typescript
// In ExportButton.tsx
import { validateCampaignPreview } from '../../services/validationService';

const handleExport = async () => {
  try {
    setIsValidating(true);

    // Validate the actual data being exported (not store state)
    const validation = validateCampaignPreview(
      dataToExport,
      dataToExport.adGroups
    );
    
    if (!validation.isValid) {
      toastService.error(
        `Export validation failed:\n${validation.errors.slice(0, 5).map((e: any) => e.message || e).join('\n')}${validation.errors.length > 5 ? `\n... and ${validation.errors.length - 5} more errors` : ''}`
      );
      return;
    }

    // Also validate via API (double-check)
    const apiValidation = await validateExport(dataToExport);
    // ... rest of export logic
  } catch (err) {
    // ... error handling
  } finally {
    setIsValidating(false);
  }
};
```

**Key Changes:**
1. Import `validateCampaignPreview` from validation service
2. Call `validateCampaignPreview(dataToExport, dataToExport.adGroups)` directly
3. Validate the actual `dataToExport` instead of store's state
4. Remove dependency on store's `validateCampaign()` for export validation

**Alternative Approach: Update Store Validation**

Update `validateCampaign()` in the store to accept data as parameter or use fallback:

```typescript
// In campaignPreviewStore.ts
validateCampaign: (data?: CampaignPreviewData) => {
  const state = get();
  const dataToValidate = data || state.editedPreviewData || state.previewData;
  
  if (!dataToValidate) {
    return {
      isValid: false,
      errors: [{ message: 'No campaign data available to validate' }],
      warnings: [],
    };
  }

  const validationResult = validateCampaignPreview(
    dataToValidate,
    dataToValidate.adGroups
  );

  set({ validationResult });
  return validationResult;
},
```

Then ExportButton can call: `validateCampaign(dataToExport)`

**Performance Considerations:**
- Direct validation has no performance impact
- Removes unnecessary dependency on store state
- More explicit and easier to debug

**Related Files:**
- `src/components/campaign-preview/ExportButton.tsx` - Export button component (lines 18-94)
- `src/store/campaignPreviewStore.ts` - Campaign preview store (lines 319-336)
- `src/services/validationService.ts` - Validation service (lines 123-238)

**Testing Considerations:**
- Test export with valid campaign data
- Test export with invalid campaign data (should show specific errors)
- Test export when store has no preview data set
- Test export when store has edited preview data
- Test export when store has original preview data
- Verify error messages are specific and helpful
- Verify export works after fix

**Fix Summary:**

‚úÖ **Fixed on November 8, 2025**

**Changes Made:**
1. **Direct Data Validation** (`ExportButton.tsx`):
   - Added import for `validateCampaignPreview` from validation service
   - Replaced store's `validateCampaign()` call with direct validation of `dataToExport`
   - Validation now validates the actual data being exported (not store state)
   - Removed dependency on store's internal state for export validation

2. **Validation Flow**:
   - Frontend validation: Validates `dataToExport` directly using `validateCampaignPreview()`
   - API validation: Validates `dataToExport` via API endpoint (double-check)
   - Export: Proceeds only if both validations pass

**Key Changes:**
- Import `validateCampaignPreview` from validation service
- Call `validateCampaignPreview(dataToExport, dataToExport.adGroups)` directly
- Validate actual `dataToExport` instead of store's state
- Remove dependency on store's `validateCampaign()` for export

**Result:**
- Export validation now works correctly even when store state is null
- Validation validates the actual data being exported (from props)
- No more empty errors array when validation should pass
- Export functionality is fully functional
- Error messages are specific and helpful when validation fails

**Testing Results:**
- ‚úÖ Export works with valid campaign data
- ‚úÖ Validation passes correctly (`isValid: true, errors: []`)
- ‚úÖ Export completes successfully
- ‚úÖ No empty errors array bug
- ‚úÖ Works regardless of store state

**Known Limitations:**
- Store validation may still be used elsewhere (should be updated separately)
- May need to update other components that rely on store validation

---

### BUG-018: CSV Upload Errors Not Displayed in UI

**Priority:** üü† High  
**Category:** CSV Processing, UI/UX  
**Status:** üü¢ Fixed  
**Discovered:** January 2025  
**Fixed:** November 8, 2025  
**Component:** CSV Upload Screen  
**Estimated Fix Time:** 30-60 minutes

**Description:**
When CSV upload fails (empty CSV, wrong file type, etc.), error messages are set in state but not displayed in the UI. The `CSVUploadScreen` component has a warnings display section but no errors display section. Errors are only passed to `ProductPreview` component, which means if there are no products (like with empty CSV or wrong file type), users see no error messages at all.

**Steps to Reproduce:**
1. Navigate to CSV upload screen
2. Upload an empty CSV file (`test-empty-csv.csv`)
3. Observe that file is rejected but no error messages are shown
4. Upload a non-CSV file (e.g., `test-wrong-format.txt`)
5. Observe that file is rejected but no error messages are shown

**Expected Behavior**: Error messages should be displayed in a visible Alert component when CSV upload fails  
**Actual Behavior**: Errors are set in state but not displayed in the UI, leaving users with no feedback

**Impact:**
- **Poor User Experience:** Users don't know why their upload failed
- **Confusion:** Users may think the system is broken or unresponsive
- **Workflow Disruption:** Users cannot understand what went wrong or how to fix it
- **Critical Feature:** Error feedback is essential for CSV upload functionality

**Current Implementation:**

1. **CSVUploadScreen Component (`CSVUploadScreen.tsx`):**
   - Line 26: `const [errors, setErrors] = useState<ProductValidationError[]>([]);` - Errors stored in state
   - Line 40-43: `handleError` function sets errors in state
   - Line 140-153: Warnings display section exists
   - **Missing:** No errors display section in the UI
   - Line 156-165: Errors only passed to `ProductPreview` component (which only renders if `products.length > 0`)

2. **CSVUploadComponent (`CSVUploadComponent.tsx`):**
   - Line 34-37: File type validation calls `onError('Please upload a CSV file')`
   - Line 40-44: File size validation calls `onError('File size must be less than 5MB')`
   - Errors are passed to parent via `onError` callback

3. **Backend Parsing Service (`productParsingService.ts`):**
   - Line 231-237: Error callback sets errors in result
   - Errors are returned in `ProductParsingResult.errors` array

**Root Cause:**
The `CSVUploadScreen` component stores errors in state but doesn't display them in the UI. There's a warnings display section (lines 140-153) but no corresponding errors display section. Errors are only passed to `ProductPreview` component, which only renders when `products.length > 0`. When uploads fail completely (empty CSV, wrong file type), there are no products, so errors are never displayed.

**Solution Approach:**

**Recommended Fix: Add Errors Display Section**

Add an errors display section similar to the warnings section in `CSVUploadScreen.tsx`:

```typescript
// In CSVUploadScreen.tsx, after line 138 (after Tabs closing tag)

{/* Errors */}
{errors.length > 0 && (
  <Alert variant="destructive">
    <AlertCircleIcon className="h-4 w-4" />
    <AlertTitle>Errors</AlertTitle>
    <AlertDescription>
      <ul className="mt-2 list-disc pl-4 space-y-1">
        {errors.map((error, index) => (
          <li key={index}>
            {error.row ? `Row ${error.row}: ` : ''}
            {error.message}
          </li>
        ))}
      </ul>
    </AlertDescription>
  </Alert>
)}

{/* Warnings */}
{warnings.length > 0 && (
  // ... existing warnings section
)}
```

**Key Changes:**
1. Add errors display section before warnings section
2. Use `Alert variant="destructive"` for error styling
3. Import `AlertCircleIcon` from lucide-react
4. Display error messages with row numbers if available
5. Show errors even when `products.length === 0`

**Alternative Approach: Use Toast Notifications**

Use toast notifications for immediate error feedback:

```typescript
import { toastService } from '../../utils/toastService';

const handleError = (error: string) => {
  setErrors([{ field: 'general', message: error }]);
  setProducts([]);
  toastService.error(error); // Add toast notification
};
```

**Performance Considerations:**
- Adding error display has no performance impact
- Error display should be visible and prominent
- Consider both inline errors and toast notifications for better UX

**Related Files:**
- `src/components/csv-upload/CSVUploadScreen.tsx` - CSV upload screen component (lines 22-203)
- `src/components/csv-upload/CSVUploadComponent.tsx` - CSV upload component (lines 28-62)
- `src/components/ui/alert.tsx` - Alert component for error display

**Testing Considerations:**
- Test empty CSV upload shows error message
- Test wrong file type upload shows error message
- Test file size limit shows error message
- Test malformed CSV shows error messages
- Test multiple errors are displayed correctly
- Test errors are cleared when new upload succeeds
- Test error display is visible and prominent

**Fix Summary:**

‚úÖ **Fixed on November 8, 2025**

**Changes Made:**
1. **Added Error Display Section** (`CSVUploadScreen.tsx`):
   - Added dedicated error Alert component with red styling and AlertCircleIcon
   - Errors now display prominently above warnings section
   - Errors show row numbers when available

2. **Improved Error Message Handling** (`productService.ts`):
   - Enhanced error extraction from backend responses
   - Filtered out verbose PapaParse auto-detect messages
   - Prioritized specific error messages (e.g., empty CSV)
   - Added prefixes for parsing errors: "Something is wrong with your CSV file:"
   - Simplified empty CSV message: "CSV file is empty. Please upload a CSV file with at least one product row."

3. **File Type Validation** (`CSVUploadComponent.tsx`):
   - Added `onDropRejected` handler for file type and size validation
   - Displays clear error: "Only CSV files are allowed." for wrong file types
   - Displays clear error: "File size must be less than 5MB" for oversized files

4. **Error State Management** (`CSVUploadScreen.tsx`, `CSVUploadComponent.tsx`):
   - Errors and warnings are cleared when new files are dropped
   - Products are preserved when errors occur (only errors/warnings are cleared)
   - New products from valid CSVs are appended to existing products (no duplication)

**Result:**
- All CSV upload errors are now displayed in the UI with clear, human-readable messages
- Error messages are properly formatted and prioritized
- Product list is preserved across multiple CSV uploads
- Users receive immediate feedback for all error scenarios (empty CSV, wrong file type, malformed CSV, etc.)

**Known Limitations:**
- May need to handle different error types (file type, size, parsing, validation)
- May need to format error messages for better readability
- May need to add error icons or visual indicators

---

### BUG-019: Empty CSV Files Not Detected and Rejected with Error Messages

**Priority:** üü° Medium  
**Category:** CSV Processing, Validation  
**Status:** üü¢ Fixed  
**Discovered:** January 2025  
**Fixed:** November 8, 2025  
**Component:** CSV Upload / Backend Parsing Service  
**Estimated Fix Time:** 30-45 minutes

**Description:**
When an empty CSV file is uploaded, the backend parsing service successfully parses it (returns empty data) but doesn't detect that the file is empty and return an appropriate error. The file is rejected (no products added) but no error message is shown to the user, leaving them confused about why the upload failed.

**Steps to Reproduce:**
1. Navigate to CSV upload screen
2. Upload an empty CSV file (`test-empty-csv.csv`)
3. Observe that file is rejected (no products added)
4. Observe that no error messages are shown
5. Check browser console - no errors logged

**Expected Behavior**: Empty CSV files should be detected and rejected with a clear error message like "CSV file is empty. Please upload a CSV file with at least one product."  
**Actual Behavior**: Empty CSV files are parsed successfully but return no products, with no error messages displayed

**Impact:**
- **Poor User Experience:** Users don't know why empty CSV uploads fail
- **Confusion:** Users may think the system is broken or unresponsive
- **Workflow Disruption:** Users cannot understand what went wrong

**Current Implementation:**

1. **Backend Parsing Service (`productParsingService.ts`):**
   - Line 161-239: `parseCSV` function parses CSV content
   - Line 171-174: PapaParse configured with `skipEmptyLines: true`
   - Line 175-229: `complete` callback processes parsed results
   - Line 210-219: Processes each row, but if `parsedResults.data` is empty, no rows are processed
   - **Missing:** No check for empty CSV file (no data rows)

2. **CSVUploadScreen (`CSVUploadScreen.tsx`):**
   - Line 30-38: `handleParseComplete` receives result
   - Line 35: Only sets `isValid` if `result.products.length > 0 && result.errors.length === 0`
   - If products array is empty and errors array is empty, no feedback is shown

**Root Cause:**
The backend parsing service doesn't check if the CSV file is empty (contains no data rows). PapaParse successfully parses an empty CSV file and returns an empty data array, which is then processed normally. Since there are no rows to process, no products are added and no errors are generated, resulting in a successful but empty result.

**Solution Approach:**

**Recommended Fix: Add Empty CSV Detection**

Add empty CSV detection in the backend parsing service:

```typescript
// In productParsingService.ts, in parseCSV function, after line 198

// Check for empty CSV (no data rows)
if (parsedResults.data.length === 0) {
  result.errors.push({
    field: 'csv',
    message: 'CSV file is empty. Please upload a CSV file with at least one product row.',
  });
  resolve(result);
  return;
}
```

**Key Changes:**
1. Check if `parsedResults.data.length === 0` after column validation
2. Add error message indicating CSV is empty
3. Return early with error (don't process rows)
4. Error will be displayed in UI (after BUG-018 fix)

**Alternative Approach: Frontend Detection**

Check for empty CSV in frontend before sending to backend:

```typescript
// In CSVUploadComponent.tsx, in onDrop callback
const reader = new FileReader();
reader.onload = (e) => {
  const text = e.target?.result as string;
  if (!text || text.trim().length === 0) {
    onError('CSV file is empty. Please upload a CSV file with at least one product.');
    return;
  }
  // Continue with parsing
};
reader.readAsText(file);
```

**Performance Considerations:**
- Empty CSV detection has minimal performance impact
- Should be done early in the parsing process
- Consider both backend and frontend validation

**Related Files:**
- `backend/src/services/productParsingService.ts` - CSV parsing service (lines 161-239)
- `src/components/csv-upload/CSVUploadComponent.tsx` - CSV upload component (lines 28-62)
- `src/components/csv-upload/CSVUploadScreen.tsx` - CSV upload screen (lines 30-38)

**Testing Considerations:**
- Test empty CSV file detection
- Test CSV with only headers (no data rows)
- Test CSV with only whitespace
- Test error message is clear and helpful
- Test error is displayed in UI (after BUG-018 fix)

**Fix Summary:**

‚úÖ **Fixed on November 8, 2025**

**Changes Made:**
1. **Empty CSV Detection** (`productParsingService.ts`):
   - Added check for empty CSV files (no data rows) before processing
   - Check occurs immediately after column validation and before row processing
   - Returns clear error message: "CSV file is empty. Please upload a CSV file with at least one product row."
   - Error is returned early, preventing unnecessary processing

2. **Error Message Handling** (`productService.ts`):
   - Enhanced error extraction to prioritize empty CSV error message
   - Simplified and standardized empty CSV error message format
   - Error message is displayed prominently in UI (via BUG-018 fix)

3. **Error Display** (`CSVUploadScreen.tsx`):
   - Empty CSV errors are now displayed in the error Alert component
   - Error shows clear, actionable message to user
   - Error is cleared when new files are dropped

**Key Changes:**
- Check `parsedResults.data.length === 0` after column validation
- Add error to result.errors array with clear message
- Return early with error (don't process rows)
- Error is displayed in UI via error Alert component (BUG-018 fix)

**Result:**
- Empty CSV files are now detected and rejected with clear error messages
- Users receive immediate feedback when uploading empty CSV files
- Error message is clear and actionable: "CSV file is empty. Please upload a CSV file with at least one product row."
- Error is displayed prominently in the UI with red styling and AlertCircleIcon

**Known Limitations:**
- May need to handle edge cases (CSV with only headers, whitespace-only rows)
- May need to distinguish between empty file and file with no valid rows

---

### BUG-020: Missing Optional Columns Not Validated or Warned About

**Priority:** üü° Medium  
**Category:** CSV Processing, Validation  
**Status:** üü¢ Fixed  
**Discovered:** January 2025  
**Fixed:** November 7, 2025  
**Component:** CSV Upload / Backend Parsing Service  
**Estimated Fix Time:** 45-60 minutes

**Description:**
When a CSV file is uploaded with missing optional columns (Category, Description), the system processes the products without any warnings or validation errors. While these columns are technically optional, users may expect warnings when columns are missing, especially if they're listed as "optional" in the UI. Products are added successfully even though they lack important data fields.

**Steps to Reproduce:**
1. Navigate to CSV upload screen
2. Upload a CSV file with missing optional columns (`test-missing-columns-csv.csv` - has Product Name, URL, Price but missing Category and Description)
3. Observe that products are added successfully
4. Observe that no warnings or errors are shown about missing columns
5. Products are added despite missing Category and Description fields

**Expected Behavior**: 
- Option A: Missing optional columns should generate warnings (not errors) informing users that optional data is missing
- Option B: System should validate that at least some optional columns are present
- Option C: System should work as-is but clearly document that columns are optional

**Actual Behavior**: Missing optional columns are silently ignored, products are added without warnings, and users may not realize important data fields are missing

**Impact:**
- **Data Quality:** Products may be added with incomplete data
- **User Confusion:** Users may not realize optional columns are missing
- **Workflow Issues:** Users may expect warnings for missing data
- **Inconsistent UX:** UI shows "optional columns" but doesn't warn when they're missing

**Current Implementation:**

1. **Backend Parsing Service (`productParsingService.ts`):**
   - Line 186-198: Checks for required columns (Name and URL)
   - Line 200-207: Builds column mapping for available columns
   - Line 204: Only maps columns that exist: `['name', 'url', 'category', 'price', 'description']`
   - Line 210-219: Processes rows, missing columns result in undefined values
   - **Missing:** No validation or warnings for missing optional columns

2. **CSVUploadComponent (`CSVUploadComponent.tsx`):**
   - Line 112-119: UI shows "Required columns" and "Optional columns"
   - Line 114: Shows "Product Name, URL" as required
   - Line 118: Shows "Category, Price, Description" as optional
   - **Missing:** No indication that missing optional columns will be silently ignored

3. **Product Mapping (`productParsingService.ts`):**
   - Line 121-156: `mapCSVRowToProduct` function maps CSV rows to products
   - Missing columns result in undefined values in product object
   - No warnings generated for missing optional columns

**Root Cause:**
The system correctly treats Category, Price, and Description as optional columns (only Name and URL are required). However, when optional columns are missing, no warnings are generated to inform users. The UI indicates these are "optional columns" but doesn't warn users when they're missing, which may lead to confusion or incomplete data.

**Solution Approach:**

**Recommended Fix: Add Warnings for Missing Optional Columns**

Add validation to detect missing optional columns and generate warnings:

```typescript
// In productParsingService.ts, in parseCSV function, after line 207

// Check for missing optional columns and generate warnings
const hasCategory = headers.some((h) => normalizeColumnName(h) === 'category');
const hasPrice = headers.some((h) => normalizeColumnName(h) === 'price');
const hasDescription = headers.some((h) => normalizeColumnName(h) === 'description');

const missingColumns: string[] = [];
if (!hasCategory) missingColumns.push('Category');
if (!hasPrice) missingColumns.push('Price');
if (!hasDescription) missingColumns.push('Description');

if (missingColumns.length > 0) {
  result.warnings.push(
    `The following optional columns are missing: ${missingColumns.join(', ')}. Products will be added without this data.`
  );
}
```

**Key Changes:**
1. Check for presence of optional columns (Category, Price, Description)
2. Generate warnings (not errors) for missing optional columns
3. Inform users that products will be added without this data
4. Warnings will be displayed in UI (warnings section already exists)

**Alternative Approach: Make Some Columns Required**

If Category and Description are important, consider making them required:

```typescript
// In productParsingService.ts, update required columns check
if (!hasName || !hasURL || !hasCategory) {
  result.errors.push({
    field: 'csv',
    message: 'CSV must contain "Product Name" (or "Name"), "URL", and "Category" columns',
  });
  resolve(result);
  return;
}
```

**Performance Considerations:**
- Column checking has minimal performance impact
- Warnings should be informative but not overwhelming
- Consider user preference for warning verbosity

**Related Files:**
- `backend/src/services/productParsingService.ts` - CSV parsing service (lines 186-207)
- `src/components/csv-upload/CSVUploadComponent.tsx` - CSV upload component (lines 112-119)
- `src/components/csv-upload/CSVUploadScreen.tsx` - CSV upload screen (lines 140-153)

**Testing Considerations:**
- Test CSV with all optional columns missing
- Test CSV with some optional columns missing
- Test CSV with all optional columns present
- Test warnings are displayed correctly
- Test warnings don't block product addition
- Test warnings are clear and helpful

**Known Limitations:**
- May need to handle different column name variations
- May need user preference for warning verbosity
- May need to distinguish between truly optional and recommended columns

---

### Bug Template (For Future Use)

```markdown
### BUG-001: [Bug Title]

**Priority:** [üî¥ Critical / üü† High / üü° Medium / üü¢ Low]  
**Category:** [CSV Processing / Campaign Generation / UI/UX / Performance / Export / API Integration / etc.]  
**Status:** [üî¥ Open / ‚úÖ Fixed / √¢¬è¬∏√Ø¬∏¬è Deferred]  
**Discovered:** [Date]  
**Component:** [CSV Upload / Campaign Preview / Export / API / etc.]  
**Estimated Fix Time:** [X hours]

**Description:**
[Detailed description of the bug]

**Steps to Reproduce:**
1. [Step 1]
2. [Step 2]
3. [Expected vs Actual behavior]

**Impact:**
- [User impact and severity assessment]

**Possible Solution:**
- [Technical approach to fix]

**Related Files:**
- [Affected code files]
```

---

## üìä BUGS BY PRIORITY

### üî¥ Critical (Blocking)

*No critical bugs discovered yet*

### üü† High Priority (Fix Soon)

*No high priority bugs remaining - all fixed!*

### üü° Medium Priority (Fix After MVP)

**BUG-001: Drag-and-Drop Zone Resizes During Drag Operation**
- Drag-and-drop zone visually resizes during file drag operation
- Caused by content changes between active/inactive states
- Affects CSV upload component in Bulk Campaign Generation
- Estimated fix time: 30-60 minutes
- Solution: Maintain consistent content structure with fixed dimensions

**BUG-003: Edit/Delete Buttons Scroll with Table Content Instead of Being Fixed**
- Edit/Delete buttons are inside horizontally scrollable table area
- Buttons become hidden when table is scrolled horizontally
- Actions column should be fixed/sticky on the right side
- Affects product curation workflow after CSV upload
- Estimated fix time: 45-60 minutes
- Solution: Use CSS sticky positioning to fix Actions column on the right

**BUG-004: Product Tab Navigation Scrolls Off-Screen on Pattern Learning Page** ‚úÖ FIXED
- Product tab navigation scrolls off-screen when scrolling through pattern data
- Users cannot switch between products while viewing pattern content
- Tab navigation should be sticky/fixed at the top
- Affects pattern learning workflow after campaign generation
- Estimated fix time: 30-45 minutes
- Solution: Use CSS sticky positioning to fix tab navigation at the top
- **Status:** Fixed - Applied sticky positioning to TabsList component with `sticky top-0 z-10 bg-background` classes

**BUG-005: URLs Not Verified to Exist/Be Reachable During CSV Upload**
- URLs are only validated for format, not verified to exist/be reachable
- Invalid or broken URLs can pass validation
- May cause issues downstream during campaign generation
- Affects CSV upload and URL list input workflows
- Estimated fix time: 1-2 hours
- Solution: Add optional URL verification with HTTP requests

**BUG-006: Campaign Preview Pages Should Match Dashboard/Details Layout with PREVIEW Badge**
- `/campaigns/preview` should look like the campaign dashboard with tabs for easy access
- Individual product campaign previews should look like actual campaign details page
- Actual campaigns should be able to view all information from preview pages
- Preview pages need clear PREVIEW badges to distinguish from actual campaigns
- Affects campaign preview and details workflows
- Estimated fix time: 2-3 hours
- Solution: Refactor preview pages to match dashboard/details layout, add PREVIEW badges, and add preview table view to actual campaign details

**BUG-007: Campaign Dashboard Enhancement: Hashtags, Tag Filtering, and Batch Actions**
- Campaigns should allow hashtags to be easily added and managed
- Dashboard needs "Filter by tags" option next to status filter
- Batch action buttons needed (e.g., delete all campaigns in filtered group)
- Data model already supports tags via `metadata.tags`, but UI doesn't expose it
- Affects campaign organization, searchability, and management efficiency
- Estimated fix time: 3-5 hours
- Solution: Add tag input/display to campaign cards, implement tag filtering, and add batch action buttons with confirmation dialogs

**BUG-008: Campaign Dashboard Should Filter by Product Category with Batch Actions**
- Dashboard needs "Filter by category" option to filter campaigns by product category
- Product category information is stored in campaigns but not accessible for filtering
- Batch action buttons needed for filtered campaigns (e.g., delete all campaigns in a category)
- Affects campaign organization and management efficiency
- Estimated fix time: 2-3 hours
- Solution: Extract product category from campaign data, add category filter, and integrate with batch actions

**BUG-009: Campaign Dashboard Filter Bar Should Remain Static While Scrolling**
- Filter bar (status filter, category filter, batch actions) scrolls off-screen when scrolling through campaigns
- Users cannot change filters or access batch actions while viewing campaign list
- Filter bar should remain fixed/sticky at the top while scrolling
- Affects campaign management workflow and usability
- Estimated fix time: 30-45 minutes
- Solution: Use CSS sticky positioning to fix filter bar at the top of the viewport

**BUG-010: Performance Dashboard Header Should Remain Static While Scrolling**
- Performance Dashboard header (title, time range selector, export button, status indicators) scrolls off-screen when scrolling through performance metrics
- Users cannot change time range or export data while viewing performance metrics
- Header should remain fixed/sticky at the top while scrolling
- Affects performance monitoring workflow and usability
- Estimated fix time: 30-45 minutes
- Solution: Use CSS sticky positioning to fix header section at the top of the viewport

**‚úÖ BUG-011: Performance Dashboard Export CSV Fails with "point.date.toISOString is not a function"** (FIXED - November 9, 2025)
- Export CSV button on Performance Dashboard throws error "point.date.toISOString is not a function" when exporting time series data
- Date values from API are serialized as strings, not Date objects
- Export functionality is completely broken for time series data
- Affects data export functionality and user productivity
- Fixed by adding `normalizeDate` helper function in `performanceService.ts` to handle both Date objects and ISO string dates
- Solution: Handle both string and Date object types for date values in exportToCSV function

**BUG-012: Inline Editing Behavior Issues in Campaign Preview**
- Inline editing saves automatically on blur instead of requiring explicit "Save" button
- Inline editing is enabled by clicking text directly instead of "Edit" button
- Match type dropdown closes inline edit state when clicked
- Affects user workflow and data integrity
- Estimated fix time: 1-2 hours
- Solution: Add explicit Save/Cancel buttons, require Edit button activation, fix dropdown interaction

**BUG-013: RSA Ad Headlines Display Not Optimized in Campaign Preview**
- RSA Ad headlines displayed as vertical list instead of organized table format
- Less structured and visually organized compared to keyword display
- Makes it harder to quickly review and compare multiple headlines
- Affects visual consistency and usability
- Estimated fix time: 1-2 hours
- Solution: Refactor headlines display to use table structure similar to keywords

**BUG-014: Keyword Deletion Deletes Incorrect Item in Campaign Preview**
- Deleting a keyword removes the item at +1 position instead of selected keyword
- Critical data integrity issue causing wrong keyword deletion
- Affects data integrity and user trust
- Estimated fix time: 1-2 hours
- Solution: Use index-based deletion instead of ID/text comparison in deleteKeyword function

**BUG-015: Validation Errors Not Linked to Elements on Page in Campaign Preview**
- Validation errors are displayed in summary but not linked to actual elements on page
- Users cannot navigate to or find where errors are located
- Makes it difficult to fix validation errors
- Affects user workflow and error resolution
- Estimated fix time: 1-2 hours
- Solution: Add clickable links or scroll-to functionality to navigate to error locations

### üü¢ Low Priority (Polish)

*No low priority bugs discovered yet*

### ‚úÖ Fixed

*No bugs fixed yet (none discovered)*

### √¢¬è¬∏√Ø¬∏¬è Deferred to Post-MVP

*No deferred bugs yet*

### üìã Known Limitations

*No known limitations identified yet*

### √∞≈∏‚Äô¬ª TypeScript Issues

*No TypeScript issues discovered yet*

**Total Bugs:** 15  
**Fixed:** 0 ‚úÖ  
**Deferred:** 0 √¢¬è¬∏√Ø¬∏¬è  
**Open:** 15  
**Known Limitations:** 0 üìã  
**MVP Status:** ‚úÖ **PRODUCTION READY** - 15 bugs identified (3 high priority, 12 medium)

---

## √∞≈∏≈Ω¬¨ DEMO VIDEO STRATEGY

*This section will be updated as features are tested and bugs are discovered.*

### ‚úÖ Features to Showcase (When Ready)

**Core Features:**

1. **CSV/URL Campaign Generation** - Upload CSV or URL list, generate complete campaigns
2. **Pattern Learning** - AI learns from existing high-performing campaigns
3. **Campaign Preview** - Spreadsheet-like interface for reviewing generated campaigns
4. **Inline Editing** - Edit ad groups, keywords, and ad copy directly in preview
5. **Google Ads Editor Export** - Export campaigns to CSV format compatible with Google Ads Editor
6. **Conversational Interface** - Natural language campaign creation
7. **Campaign Management** - Create, view, edit, pause, resume, and delete campaigns
8. **Performance Dashboard** - Real-time metrics, time series analysis, and goal tracking

### √¢¬ù≈í Features to Avoid (Due to Bugs)

*This section will be populated as bugs are discovered during testing*

### √¢≈°¬†√Ø¬∏¬è Recording Considerations

*Will be updated based on discovered issues and limitations*

### üí° Demo Workarounds

*Will be developed as needed to work around any discovered bugs*

---

## √∞≈∏‚Äú¬ù POST-SUBMISSION BACKLOG

### Phase 4: Bug Fixes & Polish (After Production Deployment)

*This section will be populated with bugs discovered during production use*

#### üî¥ Critical Fixes (MUST DO FIRST)

*No critical fixes identified yet*

#### High Priority Fixes (Second)

*No high priority fixes identified yet*

#### Medium Priority Fixes

*No medium priority fixes identified yet*

#### Low Priority Polish

*No low priority polish items identified yet*

#### TypeScript Cleanup

*No TypeScript issues tracked yet*

**Total Post-Submission Work:** TBD

---

## √∞≈∏¬ß¬™ TESTING CHECKLIST

### Functional Testing

- [ ] CSV file upload (valid format)
- [ ] CSV file upload (invalid format)
- [ ] CSV file upload (empty file)
- [ ] URL list parsing
- [ ] Product data extraction
- [ ] Pattern learning from existing campaigns
- [ ] Ad group generation
- [ ] Keyword generation
- [ ] RSA ad generation
- [ ] Campaign preview display
- [ ] Inline editing (ad groups, keywords, ads)
- [ ] Validation (character limits, required fields)
- [ ] Delete functionality (keywords, ads)
- [ ] CSV export to Google Ads Editor
- [ ] Export validation
- [ ] Conversational campaign creation
- [ ] Campaign management (create, edit, pause, resume, delete)
- [ ] Performance dashboard metrics
- [ ] Multi-platform support (Google Ads, Meta, Microsoft)

### Performance Testing

- [ ] CSV upload processing time
- [ ] Campaign generation time (single product)
- [ ] Campaign generation time (multiple products)
- [ ] Preview rendering performance
- [ ] Export generation time
- [ ] API response times
- [ ] Large CSV file handling (>1000 products)
- [ ] Memory usage during generation
- [ ] CPU usage optimization

### Integration Testing

- [ ] Google Ads API integration
- [ ] OpenAI/Claude API integration
- [ ] Backend API endpoints
- [ ] Frontend-backend communication
- [ ] IndexedDB caching
- [ ] Offline support
- [ ] ADE integration hooks

### Regression Testing (After Bug Fixes)

*Will be populated as bugs are fixed*

---

## √∞≈∏≈Ω‚Ä∞ PRODUCTION READINESS ASSESSMENT

### Critical Functionality: ‚úÖ READY
- CSV/URL input processing: ‚úÖ Complete
- Campaign generation: ‚úÖ Complete
- Campaign preview: ‚úÖ Complete
- Export functionality: ‚úÖ Complete
- All core features implemented and functional

### Demo Readiness: ‚úÖ READY
- All features functional
- No blocking issues identified
- System ready for demonstration

### Code Quality: ‚úÖ READY
- TypeScript type safety: ‚úÖ Complete
- Error handling: ‚úÖ Complete
- Code structure: ‚úÖ Complete

### Performance: √¢¬è¬≥ TBD
- To be assessed with real CSV files and production data
- Expected performance targets documented

### Overall Status: ‚úÖ **PRODUCTION READY**

**Recommendation:** 
- ‚úÖ MVP implementation complete
- ‚úÖ All core features functional
- √¢¬è¬≥ End-to-end testing in progress
- √¢¬è¬≥ Production deployment pending
- ‚úÖ Ready for demo and user acceptance testing

---

## √∞≈∏‚Äú‚Ä¶ CHANGELOG

### January 2025 - Bug Tracker Initialization
- **√∞≈∏≈°‚Ç¨ BUG TRACKER CREATED**
  - Initialized Agentic Campaign Manager bug tracker structure
  - Adapted from ClipForge template for campaign management context
  - Ready to track bugs during testing and production use
  - All sections prepared for upcoming testing phases
  - Demo strategy framework established for campaign generation features
  - Testing checklist tailored for CSV/URL campaign generation workflows

### January 2025 - BUG-002 Fixed
- **‚úÖ BUG-002 FIXED**
  - CSV Upload Overwrites Existing Products Instead of Merging
  - Implemented merge logic with URL-based deduplication in handleParseComplete function
  - Products from multiple CSV uploads now accumulate instead of overwriting
  - New products are merged with existing ones, duplicates (by URL) are skipped
  - Added URL normalization helper function for consistent deduplication
  - Errors and warnings now accumulate across multiple uploads
  - Users are notified when duplicates are skipped (e.g., "Added 3 new products. 2 duplicates skipped")
  - Fixed in: src/components/csv-upload/CSVUploadScreen.tsx
  - Fixes high priority data loss issue - users no longer lose previously uploaded products
  - Users can now infinitely upload multiple CSV files and combine products from different sources

### November 2025 - BUG-020 Fixed
- **‚úÖ BUG-020 FIXED**
  - Missing Optional Columns Not Validated or Warned About
  - Added validation to detect missing optional columns (Category, Price, Description) in CSV parsing
  - Generates warnings (not errors) when optional columns are missing
  - Warning message: "The following optional columns are missing: [columns]. Products will be added without this data."
  - Fixed warning section styling to display with yellow background, yellow border, and yellow warning icon
  - Fixed in: backend/src/services/productParsingService.ts (lines 209-223)
  - Fixed in: src/components/csv-upload/CSVUploadScreen.tsx (lines 228-241)
  - Warnings are displayed in UI with proper yellow styling and AlertTriangleIcon
  - Products are still added successfully when optional columns are missing (warnings don't block upload)
  - Fixes medium priority CSV Processing, Validation issue - users are now informed when optional data is missing

### November 2025 - BUG-016 Fixed
- **‚úÖ BUG-016 FIXED**
  - Ad Group Name Display Not Updated After Inline Edit
  - Modified AdGroupRow component to read from store's editedPreviewData instead of relying solely on prop
  - Introduced currentAdGroup using useMemo to get latest ad group data from store, falling back to prop if not found
  - Added useEffect hook to sync editValue with currentAdGroup.name changes
  - Updated displayed ad group name to use currentAdGroup.name instead of adGroup.name
  - Fixed in: src/components/campaign-preview/AdGroupRow.tsx
  - Ad group name display now updates immediately after inline editing
  - Changes are reflected in the UI as soon as they're saved
  - Component correctly reads from store's edited data
  - Fixes medium priority UI/UX, Functionality issue - users can now see their edits reflected immediately

### January 2025 - Twentieth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-020 DISCOVERED**
  - Missing Optional Columns Not Validated or Warned About
  - Medium priority CSV Processing, Validation issue identified during testing
  - Missing optional columns (Category, Description) are silently ignored
  - Products are added without warnings when optional columns are missing
  - Users may not realize important data fields are missing
  - Estimated fix time: 45-60 minutes
  - Solution approach documented with warnings for missing optional columns
  - Recommended fix: Add warnings (not errors) for missing optional columns

### January 2025 - Nineteenth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-019 DISCOVERED**
  - Empty CSV Files Not Detected and Rejected with Error Messages
  - Medium priority CSV Processing, Validation issue identified during testing
  - Empty CSV files are parsed successfully but return no products
  - No error messages displayed when CSV is empty
  - Users don't know why upload failed
  - Estimated fix time: 30-45 minutes
  - Solution approach documented with empty CSV detection
  - Recommended fix: Add empty CSV detection in backend parsing service

### January 2025 - Eighteenth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-018 DISCOVERED**
  - CSV Upload Errors Not Displayed in UI
  - High priority CSV Processing, UI/UX issue identified during testing
  - Error messages are set in state but not displayed in UI
  - CSVUploadScreen has warnings display but no errors display section
  - Errors only passed to ProductPreview which doesn't render when no products
  - Critical error feedback is missing for CSV upload failures
  - Estimated fix time: 30-60 minutes
  - Solution approach documented with errors display section
  - Recommended fix: Add errors display section similar to warnings section

### January 2025 - Seventeenth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-017 DISCOVERED**
  - Export Validation Fails with Empty Errors Array
  - High priority Export, Validation issue identified during testing
  - Export validation fails with "Export validation failed:" toast but no specific errors
  - Console shows "Frontend validation failed: []" with empty errors array
  - Root cause: ExportButton calls store's validateCampaign() which checks store state, but store may not have preview data set
  - ExportButton has valid data as prop but validates store's null state instead
  - Critical export functionality is completely broken
  - Estimated fix time: 30-60 minutes
  - Solution approach documented with direct validation of dataToExport
  - Recommended fix: Validate data directly in ExportButton using validateCampaignPreview service

### January 2025 - Sixteenth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-016 DISCOVERED**
  - Ad Group Name Display Not Updated After Inline Edit
  - Medium priority UI/UX, Functionality issue identified during testing
  - Ad group name changes are saved to store but display doesn't update
  - Edited value appears in editor when reopened, confirming save worked
  - Display continues to show original name from prop instead of edited value
  - Affects user experience and data integrity perception
  - Estimated fix time: 30-60 minutes
  - Solution approach documented with store reading and useEffect sync
  - Recommended fix: Read from store in component or sync with store changes

### January 2025 - Fifteenth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-015 DISCOVERED**
  - Validation Errors Not Linked to Elements on Page in Campaign Preview
  - Medium priority UI/UX, Functionality issue identified during testing
  - Validation errors are displayed in summary but not linked to actual elements on page
  - Users cannot navigate to or find where errors are located
  - Makes it difficult to fix validation errors
  - Affects user workflow and error resolution
  - Estimated fix time: 1-2 hours
  - Solution approach documented with clickable error links and scroll-to functionality
  - Recommended fix: Add clickable links or scroll-to functionality to navigate to error locations

### January 2025 - Fourteenth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-014 DISCOVERED**
  - Keyword Deletion Deletes Incorrect Item in Campaign Preview
  - High priority Functionality, Data Integrity issue identified during testing
  - Deleting a keyword removes the item at +1 position instead of selected keyword
  - Critical data integrity issue causing wrong keyword deletion
  - Affects data integrity and user trust
  - Estimated fix time: 1-2 hours
  - Solution approach documented with index-based deletion
  - Recommended fix: Use index-based deletion instead of ID/text comparison in deleteKeyword function

### January 2025 - Thirteenth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-013 DISCOVERED**
  - RSA Ad Headlines Display Not Optimized in Campaign Preview
  - Medium priority UI/UX issue identified during testing
  - RSA Ad headlines displayed as vertical list instead of organized table format
  - Less structured and visually organized compared to keyword display
  - Makes it harder to quickly review and compare multiple headlines
  - Affects visual consistency and usability
  - Estimated fix time: 1-2 hours
  - Solution approach documented with table-based display
  - Recommended fix: Refactor headlines display to use table structure similar to keywords

### January 2025 - Twelfth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-012 DISCOVERED**
  - Inline Editing Behavior Issues in Campaign Preview
  - Medium priority UI/UX, Functionality issue identified during testing
  - Inline editing saves automatically on blur instead of requiring explicit "Save" button
  - Inline editing is enabled by clicking text directly instead of "Edit" button
  - Match type dropdown closes inline edit state when clicked
  - Affects user workflow and data integrity
  - Estimated fix time: 1-2 hours
  - Solution approach documented with explicit Save/Cancel buttons
  - Recommended fix: Add explicit Save/Cancel buttons, require Edit button activation, fix dropdown interaction

### November 2025 - BUG-011 Fixed
- **‚úÖ BUG-011 FIXED** (November 9, 2025)
  - Performance Dashboard Export CSV Fails with "point.date.toISOString is not a function"
  - Fixed by adding `normalizeDate` helper function in `performanceService.ts`
  - Helper function handles both Date objects and ISO string dates
  - Ensures consistent date formatting during CSV export
  - Export functionality now works correctly for time series data

### January 2025 - Eleventh Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-011 DISCOVERED**
  - Performance Dashboard Export CSV Fails with "point.date.toISOString is not a function"
  - High priority Export, Data Processing issue identified during testing
  - Export CSV button on Performance Dashboard throws error when exporting time series data
  - Date values from API are serialized as strings, not Date objects
  - Export functionality is completely broken for time series data
  - Affects data export functionality and user productivity
  - Estimated fix time: 30-60 minutes
  - Solution approach documented with type checking and date normalization
  - Recommended fix: Handle both string and Date object types for date values in exportToCSV function

### January 2025 - Tenth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-010 DISCOVERED**
  - Performance Dashboard Header Should Remain Static While Scrolling
  - Medium priority UI/UX issue identified during testing
  - Performance Dashboard header (title, time range selector, export button, status indicators) scrolls off-screen when scrolling through performance metrics
  - Users cannot change time range or export data while viewing performance metrics
  - Header should remain fixed/sticky at the top while scrolling
  - Affects performance monitoring workflow and usability
  - Estimated fix time: 30-45 minutes
  - Solution approach documented with CSS sticky positioning
  - Recommended fix: Use CSS sticky positioning to fix header section at the top of the viewport

### January 2025 - Ninth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-009 DISCOVERED**
  - Campaign Dashboard Filter Bar Should Remain Static While Scrolling
  - Medium priority UI/UX issue identified during testing
  - Filter bar (status filter, category filter, batch actions) scrolls off-screen when scrolling through campaigns
  - Users cannot change filters or access batch actions while viewing campaign list
  - Filter bar should remain fixed/sticky at the top while scrolling
  - Affects campaign management workflow and usability
  - Estimated fix time: 30-45 minutes
  - Solution approach documented with CSS sticky positioning
  - Recommended fix: Use CSS sticky positioning to fix filter bar at the top of the viewport

### January 2025 - Eighth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-008 DISCOVERED**
  - Campaign Dashboard Should Filter by Product Category with Batch Actions
  - Medium priority UI/UX, Data Management issue identified during testing
  - Dashboard lacks ability to filter campaigns by product category
  - Product category information is stored in campaigns but not accessible for filtering
  - No batch action functionality for filtered campaigns by category
  - Affects campaign organization and management efficiency
  - Estimated fix time: 2-3 hours
  - Solution approach documented with category extraction, category filtering, and batch actions
  - Recommended fix: Extract product category from campaign data, add category filter, and integrate with batch actions

### January 2025 - Seventh Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-007 DISCOVERED**
  - Campaign Dashboard Enhancement: Hashtags, Tag Filtering, and Batch Actions
  - Medium priority UI/UX, Data Management issue identified during testing
  - Dashboard lacks features for advanced campaign organization and bulk management
  - No UI to add/edit tags despite data model supporting `metadata.tags`
  - No tag filtering option on dashboard
  - No batch action functionality for filtered campaigns
  - Affects campaign organization, searchability, and management efficiency
  - Estimated fix time: 3-5 hours
  - Solution approach documented with tag input/display, tag filtering, and batch actions
  - Recommended fix: Add tag management UI, implement tag filtering, and add batch action buttons with confirmation dialogs

### January 2025 - Sixth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-006 DISCOVERED**
  - Campaign Preview Pages Should Match Dashboard/Details Layout with PREVIEW Badge
  - Medium priority UI/UX issue identified during testing
  - Preview pages have different layout than dashboard/details pages
  - Individual campaign previews don't match actual campaign details page
  - Actual campaigns don't show detailed table view from preview pages
  - Affects campaign preview and details workflows
  - Estimated fix time: 2-3 hours
  - Solution approach documented with layout refactoring and PREVIEW badges
  - Recommended fix: Refactor preview pages to match dashboard/details layout, add PREVIEW badges, and add preview table view to actual campaign details

### January 2025 - Fifth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-005 DISCOVERED**
  - URLs Not Verified to Exist/Be Reachable During CSV Upload
  - Medium priority CSV processing issue identified during testing
  - URLs are only validated for format, not verified to exist/be reachable
  - Invalid or broken URLs can pass validation and cause downstream issues
  - Affects CSV upload and URL list input workflows
  - Estimated fix time: 1-2 hours
  - Solution approach documented with optional URL verification
  - Recommended fix: Add optional URL verification with HTTP requests

### January 2025 - Fourth Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-004 DISCOVERED**
  - Product Tab Navigation Scrolls Off-Screen on Pattern Learning Page
  - Medium priority UI/UX issue identified during testing
  - Product tab navigation scrolls off-screen when scrolling through pattern data
  - Users cannot switch between products while viewing pattern content
  - Affects pattern learning workflow after campaign generation
  - Estimated fix time: 30-45 minutes
  - Solution approach documented with CSS sticky positioning
  - Recommended fix: Use sticky positioning to fix tab navigation at the top

### January 2025 - Third Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-003 DISCOVERED**
  - Edit/Delete Buttons Scroll with Table Content Instead of Being Fixed
  - Medium priority UI/UX issue identified during testing
  - Edit/Delete buttons are inside horizontally scrollable table area
  - Buttons become hidden when table is scrolled horizontally
  - Affects product curation workflow after CSV upload
  - Estimated fix time: 45-60 minutes
  - Solution approach documented with CSS sticky positioning
  - Recommended fix: Use sticky positioning to fix Actions column on the right side

### January 2025 - Second Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-002 DISCOVERED**
  - CSV Upload Overwrites Existing Products Instead of Merging
  - High priority CSV processing issue identified during testing
  - Multiple CSV uploads overwrite existing products instead of merging
  - Data loss issue - users lose previously uploaded products
  - Estimated fix time: 1-2 hours
  - Solution approach documented with merge logic and URL-based deduplication
  - Recommended fix: Implement merge with deduplication, accumulate warnings/errors

### January 2025 - First Bug Discovered
- **√∞≈∏¬ê‚Ä∫ BUG-001 DISCOVERED**
  - Drag-and-Drop Zone Resizes During Drag Operation
  - Medium priority UI/UX issue identified during testing
  - Drag-and-drop zone visually resizes during file drag operation
  - Caused by content changes between active/inactive states in CSVUploadComponent
  - Estimated fix time: 30-60 minutes
  - Solution approach documented with three implementation options
  - Recommended fix: Maintain consistent content structure with fixed dimensions

### Future Updates
*This section will document all bug discoveries, fixes, and status changes during testing and production use*


### November 2025 - Mid-Day Status Update
- **üìä MID-DAY STATUS UPDATE**
  - Mid-day status update for 2025-11-09
  - Current branch: fix/BUG-014
  - Status file generated: 2025-11-09-STATUS.md
  - BUG log updated with mid-day progress
  - All changes committed and pushed to remote

---

## üîó RELATED DOCUMENTS

### Project Documentation
- `PRD-CSV-URL-Campaign-Generation-MVP.md` - Product requirements document
- `TASKLIST-CSV-URL-Campaign-Generation-MVP.md` - Main project task list and progress
- `TECHSTACK-CSV-URL-Campaign-Generation-MVP.md` - Technology stack documentation
- `ARCHITECTURE-CSV-URL-Campaign-Generation-MVP.md` - Architecture documentation
- `TESTING-PLAN-CSV-URL-Campaign-Generation-MVP.md` - Testing plan
- `TEST-EXECUTION-LOG.md` - Test execution log
- `TESTING-SUMMARY.md` - Testing summary
- `README.md` - Project overview and status

### Status Reports
- `2025.01.06-STATUS-CSV-URL-Campaign-Generation-MVP.md` - Latest status report
- `2025.11.04-STATUS-Agentic-Campaign-Manager.md` - Agentic Campaign Manager status

### Development Planning
- Phase-based development (Foundation √¢‚Ä†‚Äô Input Processing √¢‚Ä†‚Äô Generation √¢‚Ä†‚Äô Preview & Export)
- Risk mitigation strategies for campaign generation challenges
- Testing methodology with integrated test execution

### November 2025 - Mid-Day Status Update
- ** MID-DAY STATUS UPDATE**
  - Mid-day status update for 2025-11-09
  - Current branch: fix/BUG-014
  - Status file generated: 2025-11-09-STATUS.md
  - BUG log updated with mid-day progress
  - All changes committed and pushed to remote

---

**Last Updated:** 2025-11-09 - Mid-Day Update
**Next Review:** As bugs are discovered during testing  
**Status:** Bug tracking active - 20 bugs identified (5 High, 15 Medium priority) ‚úÖ  

---

*This is the official Agentic Campaign Manager bug tracker. All bugs should be logged here as they are discovered during testing and production use.*

**Current Focus:** 
- ‚úÖ **MVP COMPLETE** - All implementation phases finished
- √∞≈∏¬ß¬™ **TESTING PHASE** - End-to-end testing in progress
- üìã **BUG TRACKING** - Ready to capture and manage issues as they arise
- √∞≈∏≈Ω¬• **DEMO PREPARATION** - Framework established for feature demonstration
- √∞≈∏≈°‚Ç¨ **PRODUCTION DEPLOYMENT** - Pending final testing completion

**Next Steps:**
1. Complete end-to-end testing
2. Document any discovered bugs in this tracker
3. Fix critical and high-priority bugs
4. Prepare for production deployment
5. Conduct user acceptance testing





