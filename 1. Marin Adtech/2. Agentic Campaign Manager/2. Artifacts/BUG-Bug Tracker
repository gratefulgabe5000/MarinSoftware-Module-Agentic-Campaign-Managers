# Marin Software - Agentic Campaign Manager - Master Bug Tracker

**Version:** 1.0  
**Created:** January 2025  
**Last Updated:** January 2025 - Initialized for Development  
**Project:** Agentic Campaign Manager Module  
**Environment:** Development  
**Status:** Ready for Bug Tracking  
**Aligned Documents:** PRD v2.0 | TaskList v2.0 | Tech Stack v1.0  

---

## üìä QUICK SUMMARY

**Total Bugs:** 11  
**Enhancements:** 0 üí°  
**Known Limitations:** 0 üìã  
**Blocking Issues:** 0  
**Production Status:** ‚úÖ **READY** - No critical bugs identified  
**Demo Ready:** ‚úÖ **READY** - No blocking issues  

### Functional Bugs Breakdown

- **üî¥ Critical:** 0 bugs
- **üü† High Priority:** 1 bug (was 2, BUG-002 fixed)
- **üü° Medium Priority:** 6 bugs (was 9, BUG-001, BUG-003, and BUG-004 fixed)
- **üü¢ Low Priority:** 0 bugs
- **üìã Known Limitations:** 0

### Development Status

- **MVP Phase:** ‚úÖ Complete
- **CSV/URL Campaign Generation:** ‚úÖ Complete
- **Testing:** ‚è≥ In Progress
- **Production Deployment:** ‚è≥ Pending

**Estimated Fix Time:** 13.75-22.5 hours (7 bugs remaining)

---

## üìã BUG SUMMARY TABLE

| Bug ID | Title | Priority | Category | Status | Fix Time |
|--------|-------|----------|----------|--------|----------|
| ‚úÖ BUG-001 | Drag-and-Drop Zone Resizes During Drag Operation | üü° Medium | UI/UX | üü¢ Fixed | 30-60 min |
| ‚úÖ BUG-002 | CSV Upload Overwrites Existing Products Instead of Merging | üü† High | CSV Processing | üü¢ Fixed | 1-2 hours |
| ‚úÖ BUG-003 | Edit/Delete Buttons Scroll with Table Content Instead of Being Fixed | üü° Medium | UI/UX | üü¢ Fixed | 45-60 min |
| ‚úÖ BUG-004 | Product Tab Navigation Scrolls Off-Screen on Pattern Learning Page | üü° Medium | UI/UX | üü¢ Fixed | 30-45 min |
| BUG-005 | URLs Not Verified to Exist/Be Reachable During CSV Upload | üü° Medium | CSV Processing | üî¥ Open | 1-2 hours |
| ‚úÖ BUG-006 | Campaign Preview Pages Should Match Dashboard/Details Layout with PREVIEW Badge | üü° Medium | UI/UX | üü¢ Fixed | 2-3 hours |
| BUG-007 | Campaign Dashboard Enhancement: Hashtags, Tag Filtering, and Batch Actions | üü° Medium | UI/UX, Data Management | üî¥ Open | 3-5 hours |
| BUG-008 | Campaign Dashboard Should Filter by Product Category with Batch Actions | üü° Medium | UI/UX, Data Management | üî¥ Open | 2-3 hours |
| ‚úÖ BUG-009 | Campaign Dashboard Filter Bar Should Remain Static While Scrolling | üü° Medium | UI/UX | üü¢ Fixed | 30-45 min |
| BUG-010 | Performance Dashboard Header Should Remain Static While Scrolling | üü° Medium | UI/UX | üî¥ Open | 30-45 min |
| BUG-011 | Performance Dashboard Export CSV Fails with "point.date.toISOString is not a function" | üü† High | Export, Data Processing | üî¥ Open | 30-60 min |

**Legend:**
- üî¥ Critical = Blocking deployment/demo
- üü† High = Significant UX issue, fix soon
- üü° Medium = Notable issue, fix after submission
- üü¢ Low = Polish/enhancement, fix when time permits

**Totals:**

- üî¥ Critical: 0 bugs
- üü† High: 2 bugs
- üü° Medium: 9 bugs
- üü¢ Low: 0 bugs

---

## üéØ CURRENT STATUS

### Development Phase
**Date:** January 2025  
**Phase:** MVP Complete - Testing & Production Preparation  
**Overall Status:** ‚úÖ **READY FOR PRODUCTION**

**Implementation Complete:** ‚úÖ All Phases Complete

- ‚úÖ Phase 0: Foundation & Setup - COMPLETE
- ‚úÖ Phase 1: CSV/URL Input Processing - COMPLETE
- ‚úÖ Phase 2: Pattern Learning & Campaign Generation - COMPLETE
- ‚úÖ Phase 3: Preview & Export - COMPLETE
- ‚úÖ Conversational Interface - COMPLETE
- ‚úÖ Campaign Management - COMPLETE
- ‚úÖ Performance Dashboard - COMPLETE

**Demo Readiness:** ‚úÖ **READY**
- All core features implemented and functional
- No blocking issues identified
- System ready for end-to-end testing
- Production deployment pending

---

## üêõ FUNCTIONAL BUGS (Priority Ordered)

### BUG-001: Drag-and-Drop Zone Resizes During Drag Operation

**Priority:** üü° Medium  
**Category:** UI/UX  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** CSV Upload / Drag-and-Drop Zone  
**Estimated Fix Time:** 30-60 minutes

**Description:**
When dragging a CSV file over the drag-and-drop zone in the Bulk Campaign Generation screen, the drop zone visually resizes during the drag operation. The border and container dimensions change when `isDragActive` becomes true, causing a jarring visual effect. The drop zone should maintain consistent dimensions throughout the drag operation.

**Steps to Reproduce:**
1. Navigate to Bulk Campaign Generation screen (`/campaigns/csv-upload`)
2. Select a CSV file from the file system
3. Begin dragging the file over the drag-and-drop zone
4. Observe the drop zone as the file is dragged over it
5. Expected: Drop zone should maintain consistent size and appearance
6. Actual: Drop zone border and dimensions change/resize during drag operation

**Impact:**
- Visual inconsistency during drag operation
- Unprofessional appearance
- Potential user confusion
- Minor UX issue that affects polish

**Possible Solution:**
The issue is caused by content changes between `isDragActive` states in `CSVUploadComponent.tsx`. When `isDragActive` is true, the component shows different content (just icon and "Drop your CSV file here..."), while the inactive state shows more content (icon, text, column requirements, file size). This content difference causes the container to resize.

**Fix Approach:**
1. **Option 1 (Recommended):** Maintain consistent content structure and use CSS to show/hide elements rather than conditionally rendering different content:
   - Keep all content elements in the DOM
   - Use `opacity` and `visibility` or `display: none` to toggle visibility
   - Ensure the container maintains fixed dimensions with `min-height` or fixed height
   - Use absolute positioning for overlay states if needed

2. **Option 2:** Use fixed dimensions on the Card component:
   - Add `min-height` to the Card to prevent resizing
   - Use `height: auto` with a minimum height constraint
   - Ensure padding remains consistent

3. **Option 3:** Use CSS transitions with fixed dimensions:
   - Set explicit width and height on the drop zone
   - Use `overflow: hidden` to prevent content overflow
   - Animate only visual properties (border, background) not dimensions

**Recommended Implementation:**
```tsx
// In CSVUploadComponent.tsx, modify the Card styling:
<Card
  {...getRootProps()}
  className={cn(
    'cursor-pointer transition-all duration-200 hover:border-primary',
    'min-h-[300px]', // Add fixed minimum height
    isDragActive && 'border-primary bg-primary/5',
    isUploading && 'pointer-events-none opacity-70'
  )}
>
  <CardContent className="flex flex-col items-center justify-center p-12 text-center min-h-[300px]">
    {/* Keep content structure consistent, use conditional visibility */}
    <div className={cn(isDragActive ? 'block' : 'hidden')}>
      <UploadCloudIcon className="h-12 w-12 text-primary mb-4" />
      <p className="text-lg font-medium">Drop your CSV file here...</p>
    </div>
    <div className={cn(isDragActive ? 'hidden' : 'block')}>
      {/* Existing inactive state content */}
    </div>
  </CardContent>
</Card>
```

**Related Files:**
- `src/components/csv-upload/CSVUploadComponent.tsx` - Main component with drag-and-drop logic
- `src/components/csv-upload/CSVUploadScreen.tsx` - Parent screen component

---

### BUG-002: CSV Upload Overwrites Existing Products Instead of Merging

**Priority:** üü† High
**Category:** CSV Processing
**Status:** ‚úÖ Fixed
**Discovered:** January 2025
**Fixed:** January 2025
**Component:** CSV Upload / Product Management
**Estimated Fix Time:** 1-2 hours

**Description:**
After a CSV file has been successfully loaded and products are displayed in the preview, the drag-and-drop zone remains active. If another CSV file is dropped, it completely overwrites the existing products preview instead of merging/adding new products. The system should accumulate products from multiple CSV uploads, only adding products that don't already exist (deduplication), and this cycle should be infinitely repeatable for many CSV files.

**Steps to Reproduce:**
1. Navigate to Bulk Campaign Generation screen (`/campaigns/csv-upload`)
2. Upload first CSV file with products (e.g., 3 products)
3. Verify products appear in preview table
4. Drag and drop a second CSV file with different products (e.g., 2 new products)
5. Expected: Products from both CSVs should be displayed (5 total products)
6. Actual: Only products from the second CSV are displayed (2 products, first CSV products are lost)

**Impact:**
- **High Priority:** Data loss - users lose previously uploaded products
- Users cannot combine products from multiple CSV files
- Workflow limitation - requires manually combining CSVs before upload
- Poor user experience - unexpected behavior
- Potential frustration and time waste

**Root Cause Analysis:**
The issue is in `CSVUploadScreen.tsx` in the `handleParseComplete` function (line 30-38). Currently, it uses:
```tsx
setProducts(result.products);  // This REPLACES all products
```
This directly replaces the entire products array instead of merging with existing products.

**Solution Approach:**

### Option 1: Merge with URL-Based Deduplication (Recommended)

**Implementation Strategy:**
1. **Modify `handleParseComplete` in `CSVUploadScreen.tsx`:**
   - Instead of `setProducts(result.products)`, merge new products with existing ones
   - Use URL as the unique identifier for deduplication (normalize URLs for comparison)
   - Only add products that don't already exist (by URL)
   - Preserve existing product IDs for products that already exist
   - Update existing products if new CSV has updated data (optional - could be configurable)

2. **Deduplication Logic:**
   ```tsx
   const handleParseComplete = (result: ProductParsingResult) => {
     setProducts(prevProducts => {
       // Create a map of existing products by normalized URL
       const existingProductsMap = new Map(
         prevProducts.map(p => [normalizeUrl(p.url), p])
       );
       
       // Merge new products, skipping duplicates
       const newProducts = result.products.filter(product => {
         const normalizedUrl = normalizeUrl(product.url);
         return !existingProductsMap.has(normalizedUrl);
       });
       
       // Combine existing and new products
       return [...prevProducts, ...newProducts];
     });
     
     // Merge errors and warnings (append, don't replace)
     setErrors(prevErrors => [...prevErrors, ...result.errors]);
     setWarnings(prevWarnings => [...prevWarnings, ...result.warnings]);
   };
   
   // Helper function to normalize URLs for comparison
   const normalizeUrl = (url: string): string => {
     try {
       const urlObj = new URL(url);
       return urlObj.href.toLowerCase().trim();
     } catch {
       return url.toLowerCase().trim();
     }
   };
   ```

3. **Handle Warnings/Errors:**
   - Accumulate warnings from all uploads (show which CSV caused which warning)
   - Track errors per product (don't clear previous errors)
   - Optionally show a notification when duplicates are skipped

4. **UI Enhancements:**
   - Show count of new products added vs duplicates skipped
   - Display a toast notification: "Added X new products. Y duplicates skipped."
   - Optionally show which products came from which CSV (could add `uploadedFrom` field)
   - Add a "Clear All" button to reset products if needed

5. **File Tracking (Optional Enhancement):**
   - Track uploaded file names to show product source
   - Add `uploadedFrom?: string` to `ProductInput` type (optional)
   - Display file name in product preview table

### Option 2: Update Existing Products on Duplicate (Alternative)

If the same URL appears in a new CSV, update the existing product with new data:
```tsx
const handleParseComplete = (result: ProductParsingResult) => {
  setProducts(prevProducts => {
    const existingMap = new Map(prevProducts.map(p => [normalizeUrl(p.url), p]));
    
    result.products.forEach(newProduct => {
      const normalizedUrl = normalizeUrl(newProduct.url);
      if (existingMap.has(normalizedUrl)) {
        // Update existing product
        const existing = existingMap.get(normalizedUrl)!;
        Object.assign(existing, newProduct);
      } else {
        // Add new product
        prevProducts.push(newProduct);
      }
    });
    
    return [...prevProducts];
  });
};
```

**Recommended Implementation:**
- Use **Option 1** (skip duplicates) as default behavior
- Add a configuration option or UI toggle for "Update existing products" vs "Skip duplicates"
- Implement URL normalization for robust deduplication
- Add user feedback (toast notifications) for merge results
- Consider adding a "Clear All Products" button for reset functionality

**Additional Considerations:**
1. **10 Product Limit:** The current MVP has a 10 product limit. After merging, check if total exceeds 10 and show appropriate warning/limit.
2. **Validation:** Re-validate all products after merge to ensure no validation errors
3. **Performance:** For large CSV files, consider debouncing or batching the merge operation
4. **URL List Input:** Apply same merge logic to URL list input for consistency

**Related Files:**
- `src/components/csv-upload/CSVUploadScreen.tsx` - Main screen with `handleParseComplete` function (line 30-38)
- `src/components/csv-upload/CSVUploadComponent.tsx` - CSV upload component
- `src/components/csv-upload/URLListInput.tsx` - URL list input (should have same merge behavior)
- `src/types/product.types.ts` - Product type definitions (may need to add `uploadedFrom` field)

**Testing Considerations:**
- Test with multiple CSV files containing overlapping URLs
- Test with same product appearing in different CSVs
- Test with 10+ products total (limit handling)
- Test URL normalization (http vs https, trailing slashes, etc.)
- Test error/warning accumulation across multiple uploads

---

### BUG-003: Edit/Delete Buttons Scroll with Table Content Instead of Being Fixed

**Priority:** üü° Medium
**Category:** UI/UX
**Status:** üü¢ Fixed
**Discovered:** January 2025
**Fixed:** January 2025
**Component:** Product Preview / CSV Upload
**Estimated Fix Time:** 45-60 minutes
**Actual Fix Time:** ~45 minutes

**Description:**
The product preview table after CSV upload has edit and delete buttons in the Actions column, but these buttons are part of the horizontally scrollable table area. When the table content is wider than the viewport and users scroll horizontally, the edit/delete buttons scroll with the content and become hidden. The Actions column (with edit/delete buttons) should be fixed/sticky on the right side, remaining visible even when the table scrolls horizontally.

**Steps to Reproduce:**
1. Navigate to Bulk Campaign Generation screen (`/campaigns/csv-upload`)
2. Upload a CSV file with products that have long URLs or descriptions
3. Verify products appear in the preview table
4. Observe that the table has horizontal scroll when content is wide
5. Scroll the table horizontally to the right
6. Expected: Edit/Delete buttons should remain visible in a fixed column on the right
7. Actual: Edit/Delete buttons scroll with the table content and become hidden when scrolling right

**Impact:**
- Users cannot access edit/delete buttons when table is scrolled horizontally
- Poor user experience - actions are not always accessible
- Users must scroll back to access edit/delete functionality
- Workflow inefficiency - cannot easily edit or delete products when viewing wide content
- Common UX pattern violation - action buttons should remain accessible

**Current Implementation:**
The `ProductPreview.tsx` component has the Actions column inside the scrollable table (lines 186-349):
- Table is wrapped in `<div className="rounded-md border overflow-x-auto">` (line 186)
- Actions column is part of the table structure (line 195, 303)
- When table scrolls horizontally, all columns including Actions scroll together
- Edit and delete buttons are in the Actions column (lines 324-343)

**Root Cause:**
The Actions column is inside the scrollable container, so it scrolls with the rest of the table content. The table needs a sticky/fixed Actions column that remains visible during horizontal scrolling.

**Solution Approach:**

### Option 1: Sticky Right Column (Recommended)

**Implementation Strategy:**
1. **Restructure Table Layout:**
   - Separate the scrollable content area from the fixed Actions column
   - Use CSS `position: sticky` with `right: 0` for the Actions column
   - Ensure Actions column has a background color to prevent content showing through
   - Add appropriate z-index to ensure Actions column appears above scrolling content

2. **CSS Sticky Column Implementation:**
   ```tsx
   // In ProductPreview.tsx, modify the table structure:
   <div className="rounded-md border overflow-x-auto relative">
     <Table>
       <TableHeader>
         <TableRow>
           {/* Regular scrollable columns */}
           <TableHead className="min-w-[150px]">Name</TableHead>
           <TableHead className="min-w-[200px]">URL</TableHead>
           {/* ... other columns ... */}
           
           {/* Fixed Actions column */}
           <TableHead className="min-w-[120px] text-right sticky right-0 bg-background z-10">
             Actions
           </TableHead>
         </TableRow>
       </TableHeader>
       <TableBody>
         {products.map((product) => (
           <TableRow key={product.id}>
             {/* Regular scrollable cells */}
             <TableCell>...</TableCell>
             
             {/* Fixed Actions cell */}
             <TableCell className="text-right sticky right-0 bg-background z-10">
               {/* Edit/Delete buttons */}
             </TableCell>
           </TableRow>
         ))}
       </TableBody>
     </Table>
   </div>
   ```

3. **Alternative: Split Layout Approach:**
   - Create two separate sections: scrollable content table and fixed Actions column
   - Use flexbox or grid to position them side by side
   - Actions column remains fixed while content scrolls

**Recommended Implementation:**
```tsx
// In ProductPreview.tsx, modify the table structure:
<div className="rounded-md border overflow-x-auto relative">
  <Table>
    <TableHeader>
      <TableRow>
        <TableHead className="min-w-[150px]">Name</TableHead>
        <TableHead className="min-w-[200px]">URL</TableHead>
        <TableHead className="min-w-[120px]">Category</TableHead>
        <TableHead className="min-w-[100px]">Price</TableHead>
        <TableHead className="min-w-[200px]">Description</TableHead>
        {/* Fixed Actions column */}
        <TableHead className="min-w-[120px] text-right sticky right-0 bg-background z-10 border-l">
          Actions
        </TableHead>
      </TableRow>
    </TableHeader>
    <TableBody>
      {products.map((product) => {
        const isEditing = editingId === product.id;
        return (
          <TableRow key={product.id}>
            {/* Scrollable cells */}
            <TableCell>...</TableCell>
            
            {/* Fixed Actions cell */}
            <TableCell className="text-right sticky right-0 bg-background z-10 border-l">
              {isEditing ? (
                <div className="flex justify-end gap-1">
                  {/* Save/Cancel buttons */}
                </div>
              ) : (
                <div className="flex justify-end gap-1">
                  <Button
                    size="sm"
                    variant="ghost"
                    onClick={() => handleEdit(product)}
                    type="button"
                  >
                    <PencilIcon className="h-3 w-3" />
                  </Button>
                  <Button
                    size="sm"
                    variant="ghost"
                    onClick={() => handleRemove(product.id)}
                    type="button"
                    className="text-destructive hover:text-destructive"
                  >
                    <TrashIcon className="h-3 w-3" />
                  </Button>
                </div>
              )}
            </TableCell>
          </TableRow>
        );
      })}
    </TableBody>
  </Table>
</div>
```

**CSS Considerations:**
- Use `position: sticky` with `right: 0` for the Actions column
- Add `background-color` to prevent content showing through when scrolling
- Add `z-index` to ensure Actions column appears above scrolling content
- Add `border-left` to visually separate the fixed column
- Ensure proper width constraints to prevent layout issues

**Additional Enhancements:**
- Add shadow or border to the fixed column for better visual separation
- Ensure Actions column has sufficient width for buttons
- Test on different screen sizes to ensure sticky column works correctly
- Consider adding a visual indicator that the column is fixed

**Related Files:**
- `src/components/csv-upload/ProductPreview.tsx` - Product preview component with table structure (lines 186-349)
- `src/components/ui/table.tsx` - Table component (may need styling adjustments)

**Testing Considerations:**
- Test with wide table content that requires horizontal scrolling
- Verify Actions column remains visible when scrolling horizontally
- Test edit/delete button functionality with sticky column
- Test on different screen sizes and viewport widths
- Verify Actions column background doesn't show content bleeding through
- Test with multiple products to ensure sticky column works for all rows
- Verify z-index and layering work correctly
- Test on different browsers (sticky positioning support)

**Fix Implementation:**

The fix was implemented using Option 1 (Sticky Right Column) as recommended. Changes were made to `src/components/csv-upload/ProductPreview.tsx`:

1. **Line 195 - TableHead for Actions column:**
   - Added `sticky right-0` to fix the column to the right side
   - Added `bg-background` to ensure proper background color (prevents content showing through)
   - Added `shadow-[-4px_0_6px_-2px_rgba(0,0,0,0.1)]` for a subtle left shadow to indicate the sticky column

2. **Line 303 - TableCell for Actions column:**
   - Applied the same sticky styling: `sticky right-0 bg-background shadow-[-4px_0_6px_-2px_rgba(0,0,0,0.1)]`
   - Ensures all action buttons remain fixed during horizontal scroll

The implementation successfully makes the Actions column (containing Edit/Delete buttons) remain visible and accessible even when the table content is scrolled horizontally. The subtle shadow provides a visual indicator that separates the fixed column from the scrolling content.

**Files Modified:**
- `src/components/csv-upload/ProductPreview.tsx` (lines 195, 303)

**Verification:**
- Actions column now remains fixed on the right side during horizontal scrolling
- Edit and delete buttons are always accessible
- Background color properly masks scrolling content
- Subtle shadow provides visual separation

---

### BUG-004: Product Tab Navigation Scrolls Off-Screen on Pattern Learning Page

**Priority:** üü° Medium
**Category:** UI/UX
**Status:** üü¢ Fixed
**Discovered:** January 2025
**Fixed:** January 2025
**Component:** Pattern Learning / Tab Navigation
**Estimated Fix Time:** 30-45 minutes
**Actual Fix Time:** ~15 minutes

**Description:**
On the Pattern Learning page, after generating campaigns for CSV uploaded products, the product tab navigation (TabsList showing product names like "Yamaha SR400", "Honda CB350", "Triumph Thruxton", etc.) scrolls off-screen when users scroll through the pattern data below. The tab navigation should remain sticky/fixed at the top of the content area, allowing users to easily switch between product views without losing their place or having to scroll back up.

**Steps to Reproduce:**
1. Navigate to Bulk Campaign Generation screen (`/campaigns/csv-upload`)
2. Upload a CSV file with multiple products
3. Click "Generate Campaigns" and proceed through the workflow
4. Navigate to Pattern Learning page (`/campaigns/pattern-learning`)
5. Verify product tabs appear at the top (e.g., "Yamaha SR400", "Honda CB350", etc.)
6. Scroll down through the pattern data content
7. Expected: Product tab navigation should remain visible at the top
8. Actual: Product tab navigation scrolls off-screen with the content

**Impact:**
- Users cannot easily switch between products while viewing pattern data
- Poor user experience - must scroll back to top to change products
- Workflow inefficiency - interrupts pattern review process
- Common UX pattern violation - navigation should remain accessible
- Users may lose their place when scrolling back up

**Current Implementation:**
The `PatternLearningScreen.tsx` component has the TabsList inside the main content area (lines 259-268):
- TabsList is inside the main content div (line 238: `<div className="mx-auto max-w-7xl space-y-6">`)
- TabsList is not sticky or fixed (line 261: `<TabsList className="grid w-full"...>`)
- When content below is scrolled, the TabsList scrolls with it
- No sticky positioning applied to the tab navigation

**Root Cause:**
The TabsList is part of the normal document flow and is not positioned as sticky. When users scroll through the pattern data content below, the entire page scrolls, including the tab navigation.

**Solution Approach:**

### Option 1: Sticky Tab Navigation (Recommended)

**Implementation Strategy:**
1. **Make TabsList Sticky:**
   - Apply CSS `position: sticky` with `top: 0` to the TabsList
   - Add background color to prevent content showing through
   - Add appropriate z-index to ensure tabs appear above scrolling content
   - Add shadow or border for visual separation when sticky

2. **CSS Sticky Implementation:**
   ```tsx
   // In PatternLearningScreen.tsx, modify the TabsList:
   <Tabs value={activeProductTab} onValueChange={setActiveProductTab}>
     <TabsList 
       className="grid w-full sticky top-0 bg-background z-10 border-b shadow-sm"
       style={{ gridTemplateColumns: `repeat(${products.length}, minmax(0, 1fr))` }}
     >
       {products.map((product: any, index: number) => (
         <TabsTrigger key={product.id} value={String(index)}>
           <PackageIcon className="h-4 w-4 mr-2" />
           <span className="truncate max-w-[150px]">{product.name}</span>
         </TabsTrigger>
       ))}
     </TabsList>
     {/* TabsContent below */}
   </Tabs>
   ```

3. **Alternative: Sticky Container Approach:**
   - Wrap the TabsList in a sticky container div
   - Apply sticky positioning to the container
   - Ensure proper spacing and background

**Recommended Implementation:**
```tsx
// In PatternLearningScreen.tsx, modify the Tabs section:
{products.length > 0 && productPatterns.length > 0 && (
  <Tabs value={activeProductTab} onValueChange={setActiveProductTab}>
    {/* Sticky tab navigation */}
    <div className="sticky top-0 bg-background z-10 border-b shadow-sm mb-6">
      <TabsList 
        className="grid w-full"
        style={{ gridTemplateColumns: `repeat(${products.length}, minmax(0, 1fr))` }}
      >
        {products.map((product: any, index: number) => (
          <TabsTrigger key={product.id} value={String(index)}>
            <PackageIcon className="h-4 w-4 mr-2" />
            <span className="truncate max-w-[150px]">{product.name}</span>
          </TabsTrigger>
        ))}
      </TabsList>
    </div>

    {/* Tab content below (scrollable) */}
    {productPatterns.map((productPattern: CampaignPatterns, index: number) => (
      <TabsContent key={products[index].id} value={String(index)} className="space-y-6">
        {/* Pattern content */}
      </TabsContent>
    ))}
  </Tabs>
)}
```

**CSS Considerations:**
- Use `position: sticky` with `top: 0` for the tab navigation
- Add `background-color` (bg-background) to prevent content showing through
- Add `z-index` (z-10) to ensure tabs appear above scrolling content
- Add `border-b` or `shadow-sm` for visual separation when sticky
- Consider adding padding to the sticky container for better spacing

**Additional Enhancements:**
- Add smooth scroll behavior when switching tabs
- Consider adding a visual indicator when tabs are sticky
- Ensure tabs work correctly on mobile devices
- Test with many products (horizontal scrolling of tabs)

**Related Files:**
- `src/components/pattern-learning/PatternLearningScreen.tsx` - Pattern learning screen with tab navigation (lines 259-293)
- `src/components/ui/tabs.tsx` - Tabs component (may need styling adjustments)

**Testing Considerations:**
- Test with multiple products (3+ tabs)
- Verify tab navigation remains visible when scrolling through pattern data
- Test tab switching functionality with sticky navigation
- Test on different screen sizes and viewport heights
- Verify tab navigation background doesn't show content bleeding through
- Test with long pattern data that requires significant scrolling
- Verify z-index and layering work correctly
- Test on different browsers (sticky positioning support)
- Test with many products (horizontal scrolling of tabs)

**Fix Applied:**

The fix was implemented by applying CSS sticky positioning directly to the TabsList component in `PatternLearningScreen.tsx:261`.

**Changes Made:**
- Modified `TabsList` className from `"grid w-full"` to `"grid w-full sticky top-0 z-10 bg-background"`
- Added `sticky` class for sticky positioning
- Added `top-0` to stick the element to the top of the viewport (0px from top)
- Added `z-10` to ensure the tab navigation appears above scrolling content
- Added `bg-background` to provide a solid background and prevent content bleeding through

**Code Change:**
```tsx
// Before (line 261):
<TabsList className="grid w-full" style={{ gridTemplateColumns: `repeat(${products.length}, minmax(0, 1fr))` }}>

// After (line 261):
<TabsList className="grid w-full sticky top-0 z-10 bg-background" style={{ gridTemplateColumns: `repeat(${products.length}, minmax(0, 1fr))` }}>
```

**Result:**
The product tab navigation now remains fixed at the top of the viewport when users scroll through the pattern data, allowing easy switching between products without losing their place or scrolling back up.

**Files Modified:**
- `src/components/pattern-learning/PatternLearningScreen.tsx` (line 261)

---

### BUG-005: URLs Not Verified to Exist/Be Reachable During CSV Upload

**Priority:** üü° Medium  
**Category:** CSV Processing  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** CSV Upload / URL Validation  
**Estimated Fix Time:** 1-2 hours

**Description:**
When uploading a CSV file with product URLs, the system only validates that URLs are well-formed (correct format with http:// or https:// protocol) but does not verify that the URLs actually exist or are reachable. Invalid, broken, or non-existent URLs can pass validation and cause issues downstream during campaign generation. The system should optionally verify that URLs are accessible before accepting them.

**Steps to Reproduce:**
1. Navigate to Bulk Campaign Generation screen (`/campaigns/csv-upload`)
2. Create a CSV file with a product that has a well-formed but non-existent URL (e.g., `https://example.com/nonexistent-product-page`)
3. Upload the CSV file
4. Expected: System should verify URL exists and is reachable, or at least warn about unverified URLs
5. Actual: URL passes validation if it's well-formed, even if it doesn't exist or is unreachable

**Impact:**
- Invalid URLs can be accepted and cause issues during campaign generation
- Broken links in generated campaigns
- Poor user experience - users discover invalid URLs only after campaign generation
- Potential wasted API calls and processing time for invalid URLs
- Campaigns may fail or produce errors when trying to use invalid URLs

**Current Implementation:**
The URL validation only checks format, not existence:
- `productParsingService.ts` (line 27-34): `isValidURL()` function only checks URL format using `new URL()` and protocol validation
- `validationService.ts` (line 105-118): `validateUrl()` function only validates format, not reachability
- No HTTP requests are made to verify URLs exist
- No network checks to verify URLs are accessible

**Root Cause:**
The validation logic only checks if the URL string is well-formed (valid URL format with http/https protocol) but does not make any HTTP requests to verify the URL actually exists or is reachable.

**Solution Approach:**

### Option 1: Optional URL Verification (Recommended)

**Implementation Strategy:**
1. **Add URL Verification Service:**
   - Create a URL verification service that makes HEAD or GET requests to verify URLs
   - Use axios or fetch to check if URL is reachable
   - Set reasonable timeout (e.g., 5-10 seconds per URL)
   - Handle errors gracefully (network errors, timeouts, 404s, etc.)

2. **Verification Logic:**
   ```tsx
   // In productParsingService.ts or new urlVerificationService.ts:
   async function verifyUrlExists(url: string): Promise<{ exists: boolean; error?: string }> {
     try {
       const response = await axios.head(url, {
         timeout: 5000, // 5 second timeout
         maxRedirects: 5,
         validateStatus: (status) => status < 500, // Accept 2xx, 3xx, 4xx as "exists"
       });
       
       // Consider 2xx and 3xx as valid, 4xx as potentially invalid
       if (response.status >= 200 && response.status < 400) {
         return { exists: true };
       } else if (response.status === 404) {
         return { exists: false, error: 'URL not found (404)' };
       } else {
         return { exists: false, error: `URL returned status ${response.status}` };
       }
     } catch (error) {
       if (axios.isAxiosError(error)) {
         if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
           return { exists: false, error: 'URL is not reachable' };
         }
         if (error.code === 'ETIMEDOUT') {
           return { exists: false, error: 'URL verification timed out' };
         }
       }
       return { exists: false, error: 'Failed to verify URL' };
     }
   }
   ```

3. **Integration Options:**
   - **Option A (Recommended):** Make verification optional with a toggle/checkbox
     - Add "Verify URLs" checkbox in CSV upload screen
     - Only verify if user opts in (to avoid delays for large CSVs)
     - Show progress indicator during verification
   
   - **Option B:** Always verify but in background
     - Verify URLs asynchronously after CSV parsing
     - Show warnings for invalid URLs but don't block workflow
     - Allow users to proceed with warnings
   
   - **Option C:** Verify on-demand
     - Add "Verify URLs" button after CSV upload
     - Users can manually trigger verification
     - Show results with warnings/errors

4. **User Feedback:**
   - Show verification progress (e.g., "Verifying URL 3 of 10...")
   - Display warnings for unreachable URLs
   - Allow users to proceed with warnings or fix URLs
   - Show which URLs failed verification

**Recommended Implementation:**
```tsx
// In productParsingService.ts, add URL verification:
export async function parseCSVWithVerification(
  csvContent: string,
  verifyUrls: boolean = false
): Promise<ProductParsingResult> {
  const result = await parseCSV(csvContent);
  
  if (verifyUrls && result.products.length > 0) {
    // Verify URLs in parallel with rate limiting
    const verificationPromises = result.products.map(async (product) => {
      if (product.url) {
        const verification = await verifyUrlExists(product.url);
        if (!verification.exists) {
          result.warnings.push(
            `URL may be invalid for "${product.name}": ${verification.error || 'URL not reachable'}`
          );
        }
      }
    });
    
    await Promise.all(verificationPromises);
  }
  
  return result;
}

// In CSVUploadScreen.tsx, add verification option:
const [verifyUrls, setVerifyUrls] = useState(false);

// Add checkbox:
<label>
  <input 
    type="checkbox" 
    checked={verifyUrls} 
    onChange={(e) => setVerifyUrls(e.target.checked)}
  />
  Verify URLs are reachable (may take longer)
</label>
```

**Performance Considerations:**
- URL verification can be slow (network requests)
- For 10 products, verification could take 10-50 seconds
- Consider parallel verification with rate limiting
- Add timeout to prevent hanging on slow/unreachable URLs
- Cache verification results to avoid re-verifying same URLs
- Consider making it optional to avoid blocking workflow

**Alternative Approaches:**
1. **Client-Side Only Verification:**
   - Use CORS-enabled fetch requests from browser
   - Limited by CORS policies
   - May not work for all URLs

2. **Backend Verification Service:**
   - Create dedicated endpoint for URL verification
   - Backend makes HTTP requests (no CORS issues)
   - Can batch verify multiple URLs
   - Better for production use

3. **Progressive Verification:**
   - Verify URLs in background after CSV upload
   - Show warnings as verification completes
   - Don't block user workflow

**Related Files:**
- `backend/src/services/productParsingService.ts` - Product parsing service with URL validation (lines 27-34, 60-72)
- `src/services/validationService.ts` - Frontend validation service (lines 105-118)
- `src/components/csv-upload/CSVUploadScreen.tsx` - CSV upload screen component
- `src/components/csv-upload/ProductPreview.tsx` - Product preview with URL display

**Testing Considerations:**
- Test with valid, reachable URLs
- Test with invalid URLs (404, broken links)
- Test with unreachable URLs (wrong domain, network errors)
- Test with URLs that timeout
- Test with many URLs (performance)
- Test verification timeout handling
- Test with CORS-restricted URLs
- Test optional verification toggle
- Test user experience with verification delays
- Test error handling for network failures

**Known Limitations:**
- URL verification requires network requests and can be slow
- Some URLs may be behind authentication or firewalls
- CORS policies may prevent client-side verification
- Rate limiting may be needed for many URLs
- False positives/negatives possible (temporary network issues)

---

### BUG-006: Campaign Preview Pages Should Match Dashboard/Details Layout with PREVIEW Badge

**Priority:** üü° Medium  
**Category:** UI/UX  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Campaign Preview / Campaign Details  
**Estimated Fix Time:** 2-3 hours

**Description:**
The campaign preview pages (`/campaigns/preview`) and individual product campaign previews have a different layout and structure than the campaign dashboard and actual campaign details pages. This creates inconsistency in the user experience and makes it difficult to navigate between preview and actual campaigns. Additionally, actual campaign details pages do not show the detailed table view (ad groups, keywords, ads) that is available in the preview pages. The preview pages should match the dashboard/details layout with clear PREVIEW badges, and actual campaigns should be able to view all the information from preview pages.

**Steps to Reproduce:**
1. Navigate to `/campaigns/preview` after generating campaigns
2. Observe the current layout (dropdown selector, table view)
3. Navigate to `/campaigns` (dashboard) and observe the layout (campaign cards, filters)
4. Navigate to `/campaign/:id` (campaign details) and observe the layout (overview card, status, information)
5. Expected: Preview page should look like dashboard with tabs for easy access, individual previews should look like details page, and actual campaigns should show the detailed table view
6. Actual: Preview page has different layout, individual previews don't match details page, and actual campaigns don't show detailed table view

**Impact:**
- Inconsistent user experience between preview and actual campaigns
- Difficult navigation between preview and actual campaign views
- Missing information in actual campaign details (detailed table view with ad groups, keywords, ads)
- Users cannot easily switch between multiple preview campaigns
- Preview pages don't clearly indicate they are previews (no PREVIEW badge)
- Actual campaigns cannot view the same detailed information available in preview

**Current Implementation:**
1. **`/campaigns/preview` (CampaignPreviewScreen.tsx):**
   - Shows a dropdown selector for campaigns (if multiple)
   - Displays a single campaign preview table
   - Has validation summary and export functionality
   - Does NOT have tabs for easy navigation between campaigns
   - Does NOT match the dashboard layout

2. **Individual Campaign Preview:**
   - Shows campaign preview table with ad groups, keywords, and ads
   - Has filtering and sorting capabilities
   - Has inline editing capabilities
   - Does NOT match the campaign details page layout
   - Does NOT have PREVIEW badge

3. **`/campaign/:id` (CampaignDetail.tsx):**
   - Shows campaign overview card
   - Shows campaign status
   - Shows campaign information
   - Shows platform campaign IDs
   - Shows campaign actions
   - Does NOT show the detailed table view (ad groups, keywords, ads) from preview

**Root Cause:**
The preview pages were built with a different structure than the dashboard and details pages. The preview pages focus on editing and export functionality, while the dashboard and details pages focus on management and status. Additionally, the detailed table view component (CampaignPreviewTable) is only used in preview pages and not integrated into the actual campaign details page.

**Solution Approach:**

### Option 1: Refactor Preview Pages to Match Dashboard/Details Layout (Recommended)

**Implementation Strategy:**

1. **Refactor `/campaigns/preview` to Match Dashboard Layout:**
   - Replace dropdown selector with tabs (similar to dashboard campaign cards)
   - Show campaign cards in a grid layout (like dashboard)
   - Add PREVIEW badge to each campaign card
   - Add tabs for easy navigation between campaigns
   - Keep the preview table view when a campaign is selected
   - Add "Back to Dashboard" button

2. **Refactor Individual Campaign Preview to Match Details Page:**
   - Use the same layout structure as `CampaignDetail.tsx`
   - Show campaign overview card (with PREVIEW badge)
   - Show campaign status section (marked as PREVIEW)
   - Show campaign information section
   - Show the detailed table view (ad groups, keywords, ads) as a new section
   - Add PREVIEW badge prominently in the header
   - Keep inline editing and export functionality

3. **Add Detailed Table View to Actual Campaign Details:**
   - Add a new "Campaign Structure" or "Ad Groups & Ads" section to `CampaignDetail.tsx`
   - Reuse `CampaignPreviewTable` component (or create a read-only version)
   - Transform campaign data to `CampaignPreviewData` format
   - Show the table view with ad groups, keywords, and ads
   - Make it read-only (no editing) for actual campaigns
   - Add expand/collapse functionality for ad groups

4. **Add PREVIEW Badges:**
   - Add prominent PREVIEW badge to preview page header
   - Add PREVIEW badge to each campaign card in preview dashboard
   - Add PREVIEW badge to individual campaign preview header
   - Use consistent styling (e.g., yellow/orange badge with "PREVIEW" text)

**Recommended Implementation:**

```tsx
// In CampaignPreviewScreen.tsx, refactor to match dashboard layout:
const CampaignPreviewScreen: React.FC = () => {
  // ... existing code ...
  
  return (
    <div className="min-h-screen bg-background p-8">
      <div className="mx-auto max-w-7xl space-y-8">
        {/* Header with PREVIEW badge */}
        <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
          <div className="flex items-center gap-3">
            <h1 className="text-3xl font-bold tracking-tight">Campaign Preview</h1>
            <Badge variant="outline" className="bg-yellow-500/10 text-yellow-700 border-yellow-500/20">
              PREVIEW
            </Badge>
          </div>
          <Button variant="outline" onClick={handleBackToDashboard} type="button">
            <ArrowLeftIcon className="h-4 w-4" />
            Back to Dashboard
          </Button>
        </div>

        {/* Campaign Tabs (if multiple campaigns) */}
        {campaigns.length > 1 && (
          <Tabs value={selectedCampaign?.campaignId || ''} onValueChange={handleCampaignSelect}>
            <TabsList>
              {campaigns.map((campaign) => (
                <TabsTrigger key={campaign.id} value={campaign.id}>
                  {campaign.name}
                </TabsTrigger>
              ))}
            </TabsList>
          </Tabs>
        )}

        {/* Campaign Preview Content (matching details page layout) */}
        {selectedCampaign && (
          <div className="space-y-6">
            {/* Campaign Overview Card with PREVIEW badge */}
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <CardTitle>{selectedCampaign.campaignName}</CardTitle>
                  <Badge variant="outline" className="bg-yellow-500/10 text-yellow-700 border-yellow-500/20">
                    PREVIEW
                  </Badge>
                </div>
              </CardHeader>
              <CardContent>
                {/* Campaign overview information */}
              </CardContent>
            </Card>

            {/* Detailed Table View */}
            <CampaignPreviewTable previewData={selectedCampaign} />
          </div>
        )}
      </div>
    </div>
  );
};

// In CampaignDetail.tsx, add detailed table view:
const CampaignDetail: React.FC = () => {
  // ... existing code ...
  
  // Transform campaign to preview data format
  const previewData = useMemo(() => {
    if (!campaign?.campaignPlan) return null;
    // Transform campaign.campaignPlan to CampaignPreviewData format
    return transformCampaignToPreviewData(campaign);
  }, [campaign]);

  return (
    <div className="min-h-screen bg-background p-8">
      <div className="mx-auto max-w-7xl space-y-6">
        {/* ... existing header and overview sections ... */}

        {/* New: Campaign Structure Section */}
        {previewData && (
          <Card>
            <CardHeader>
              <CardTitle>Campaign Structure</CardTitle>
              <CardDescription>
                View ad groups, keywords, and ads for this campaign
              </CardDescription>
            </CardHeader>
            <CardContent>
              <CampaignPreviewTable 
                previewData={previewData} 
                readOnly={true} // Read-only for actual campaigns
              />
            </CardContent>
          </Card>
        )}

        {/* ... existing sections ... */}
      </div>
    </div>
  );
};
```

**Alternative Approaches:**

1. **Create Shared Layout Component:**
   - Create a shared `CampaignLayout` component
   - Use it for both preview and actual campaign pages
   - Pass `isPreview` prop to show/hide PREVIEW badges
   - Pass `readOnly` prop to enable/disable editing

2. **Create Read-Only Table Component:**
   - Create `CampaignStructureTable` component (read-only version)
   - Use it in actual campaign details page
   - Keep `CampaignPreviewTable` for preview pages (with editing)

3. **Add Tabs to Preview Screen:**
   - Use Tabs component from shadcn/ui
   - Show one tab per campaign
   - Allow easy switching between campaigns
   - Keep the table view in each tab

**Performance Considerations:**
- Transforming campaign data to preview format may be expensive
- Consider memoizing the transformation
- Lazy load the detailed table view if it's large
- Consider pagination for campaigns with many ad groups

**Related Files:**
- `src/components/campaign-preview/CampaignPreviewScreen.tsx` - Main preview screen (lines 1-311)
- `src/components/campaign-preview/CampaignPreviewTable.tsx` - Preview table component (lines 1-217)
- `src/components/CampaignDashboard.tsx` - Campaign dashboard (lines 1-477)
- `src/components/CampaignDetail.tsx` - Campaign details page (lines 1-363)
- `src/components/CampaignOverviewCard.tsx` - Campaign overview card component
- `src/types/campaign-preview.types.ts` - Preview data types

**Testing Considerations:**
- Test preview page with single campaign
- Test preview page with multiple campaigns (tabs)
- Test individual campaign preview layout
- Test PREVIEW badges are visible and consistent
- Test actual campaign details page with detailed table view
- Test navigation between preview and actual campaigns
- Test that preview editing works correctly
- Test that actual campaign table view is read-only
- Test responsive layout on different screen sizes
- Test that all information from preview is available in actual campaigns

**Known Limitations:**
- Preview pages may need significant refactoring
- May require updating multiple components
- Need to ensure data transformation works correctly
- May need to handle edge cases (campaigns without ad groups, etc.)

---

### BUG-007: Campaign Dashboard Enhancement: Hashtags, Tag Filtering, and Batch Actions

**Priority:** üü° Medium  
**Category:** UI/UX, Data Management  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Campaign Dashboard / Campaign Management  
**Estimated Fix Time:** 3-5 hours

**Description:**
The Campaign Dashboard currently lacks features for advanced campaign organization and bulk management. While the campaign data model already supports tags via `metadata.tags`, there is no UI to add, edit, or filter by tags. Additionally, there are no batch action capabilities to perform operations on multiple campaigns simultaneously. This enhancement addresses three key areas:
1. **Hashtags for Campaigns:** Users should be able to easily add and manage hashtags on campaigns.
2. **Filter by Tags:** A new filter option is needed on the dashboard to filter campaigns based on these hashtags.
3. **Batch Action Buttons:** Functionality to perform batch actions (e.g., delete all campaigns in a filtered group) should be available next to the tag filter.

**Steps to Reproduce:**
1. Navigate to the Campaign Dashboard (`/campaigns`)
2. Observe that there is no UI element to add hashtags to existing campaigns
3. Observe that the filter section only allows filtering by status, with no option to filter by tags
4. Observe that there are no batch action buttons available to perform operations on multiple campaigns simultaneously
5. Expected: Users should be able to add tags to campaigns, filter by tags, and perform batch actions on filtered campaigns
6. Actual: No tag management, tag filtering, or batch action functionality exists

**Impact:**
- **Poor Organization:** Users cannot categorize or group campaigns beyond their basic status
- **Difficult Searchability:** Difficult to find specific campaigns in a large list without tag-based filtering
- **Inefficient Management:** No way to perform bulk operations (like deletion) on multiple campaigns, requiring manual, individual actions
- **Underutilized Data Model:** The `metadata.tags` field exists in the data model but is not accessible through the UI

**Current Implementation:**
1. **Campaign Data Model:**
   - `Campaign` interface includes `metadata?: CampaignMetadata`
   - `CampaignMetadata` interface includes `tags?: string[]`
   - Backend also supports tags in campaign metadata
   - Tags are stored but not displayed or editable in the UI

2. **Campaign Dashboard (`CampaignDashboard.tsx`):**
   - Only filters by status (All, Draft, Active)
   - Shows campaign cards with basic information (name, status, platforms, budget, created date)
   - Individual delete button per campaign card
   - No tag display, tag input, or tag filtering
   - No batch action functionality

3. **Campaign Store:**
   - `useCampaignStore` manages campaign state
   - `updateCampaign` function exists but may need to handle metadata updates
   - No specific tag management functions

**Root Cause:**
The campaign data model supports tags, but the UI components were not built to expose or manage this functionality. The dashboard was designed with only status-based filtering and individual campaign actions, without considering tag-based organization or batch operations.

**Solution Approach:**

### Option 1: Complete Dashboard Enhancement (Recommended)

**Implementation Strategy:**

1. **Add Tag Input/Display to Campaign Cards:**
   - Add a tag input field or "Add Tag" button to each campaign card
   - Display existing tags as clickable badges on the campaign card
   - Allow inline editing of tags (add/remove)
   - Use a tag input component (e.g., multi-select with autocomplete)
   - Update campaign metadata when tags are added/removed

2. **Add "Filter by Tags" Component:**
   - Add a new filter section next to "Filter by status" in the filter card
   - Create a multi-select dropdown or tag selector component
   - Show all unique tags from all campaigns
   - Allow filtering by one or more tags
   - Combine tag filter with status filter (AND logic)
   - Show count of campaigns matching selected tags

3. **Add Batch Action Buttons:**
   - Add a batch actions container next to the tag filter
   - Add "Delete All Filtered" button (destructive action)
   - Show count of campaigns that will be affected
   - Implement confirmation dialog for batch delete
   - Add loading state during batch operations
   - Show success/error messages after batch operations

4. **Update Campaign Store:**
   - Ensure `updateCampaign` properly handles metadata updates
   - Add helper functions for tag management if needed
   - Update IndexedDB schema if necessary

5. **Backend API Updates (if needed):**
   - Ensure campaign update endpoint supports metadata updates
   - Add batch delete endpoint if not exists
   - Support filtering by tags in campaign queries

**Recommended Implementation:**

```tsx
// In CampaignDashboard.tsx, add tag state and filtering:
const CampaignDashboard: React.FC = () => {
  // ... existing state ...
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [showBatchDeleteConfirm, setShowBatchDeleteConfirm] = useState(false);

  // Get all unique tags from campaigns
  const allTags = useMemo(() => {
    const tagSet = new Set<string>();
    campaigns.forEach(campaign => {
      campaign.metadata?.tags?.forEach(tag => tagSet.add(tag));
    });
    return Array.from(tagSet).sort();
  }, [campaigns]);

  // Filter campaigns by status AND tags
  const filteredCampaigns = useMemo(() => {
    let filtered = campaigns;
    
    // Filter by status
    if (statusFilter !== 'all') {
      filtered = filtered.filter(c => c.status === statusFilter);
    }
    
    // Filter by tags
    if (selectedTags.length > 0) {
      filtered = filtered.filter(campaign => {
        const campaignTags = campaign.metadata?.tags || [];
        return selectedTags.every(tag => campaignTags.includes(tag));
      });
    }
    
    return filtered;
  }, [campaigns, statusFilter, selectedTags]);

  // Handle tag update for a campaign
  const handleTagUpdate = async (campaignId: string, tags: string[]) => {
    try {
      await campaignService.updateCampaign(campaignId, {
        metadata: { tags }
      });
      updateCampaignStore(campaignId, {
        metadata: { tags }
      });
      toastService.success('Tags updated successfully');
    } catch (error) {
      toastService.error('Failed to update tags');
    }
  };

  // Handle batch delete
  const handleBatchDelete = async () => {
    try {
      const campaignIds = filteredCampaigns.map(c => c.id);
      // Delete campaigns in parallel
      await Promise.all(
        campaignIds.map(id => campaignService.deleteCampaign(id))
      );
      // Remove from store
      campaignIds.forEach(id => removeCampaign(id));
      toastService.success(`Deleted ${campaignIds.length} campaigns`);
      setShowBatchDeleteConfirm(false);
      setSelectedTags([]);
      setStatusFilter('all');
    } catch (error) {
      toastService.error('Failed to delete campaigns');
    }
  };

  return (
    <div className="min-h-screen bg-background p-8">
      <div className="mx-auto max-w-7xl space-y-8">
        {/* ... existing header ... */}

        {/* Enhanced Filter Section */}
        {campaigns.length > 0 && (
          <Card>
            <CardContent className="pt-6">
              <div className="space-y-4">
                {/* Status Filter */}
                <div className="flex items-center gap-2 flex-wrap">
                  <FilterIcon className="h-4 w-4 text-muted-foreground" />
                  <span className="text-sm font-medium text-muted-foreground">Filter by status:</span>
                  <div className="flex gap-2 flex-wrap">
                    {/* ... existing status filter buttons ... */}
                  </div>
                </div>

                {/* Tag Filter */}
                <div className="flex items-center gap-2 flex-wrap">
                  <span className="text-sm font-medium text-muted-foreground">Filter by tags:</span>
                  <Select
                    value={selectedTags.join(',')}
                    onValueChange={(value) => setSelectedTags(value ? value.split(',') : [])}
                  >
                    <SelectTrigger className="w-[250px]">
                      <SelectValue placeholder="Select tags..." />
                    </SelectTrigger>
                    <SelectContent>
                      {allTags.map(tag => (
                        <SelectItem key={tag} value={tag}>
                          {tag} ({campaigns.filter(c => c.metadata?.tags?.includes(tag)).length})
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  {selectedTags.length > 0 && (
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => setSelectedTags([])}
                      type="button"
                    >
                      Clear tags
                    </Button>
                  )}
                </div>

                {/* Batch Actions */}
                {filteredCampaigns.length > 0 && (
                  <div className="flex items-center gap-2 flex-wrap border-t pt-4">
                    <span className="text-sm font-medium text-muted-foreground">
                      Batch actions ({filteredCampaigns.length} campaigns):
                    </span>
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => setShowBatchDeleteConfirm(true)}
                      type="button"
                    >
                      <TrashIcon className="h-4 w-4" />
                      Delete All Filtered
                    </Button>
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        )}

        {/* Campaign Cards with Tags */}
        {filteredCampaigns.map((campaign) => (
          <Card key={campaign.id}>
            {/* ... existing card content ... */}
            
            {/* Add Tags Section */}
            <CardContent>
              <div className="space-y-2">
                <div className="flex items-center gap-2 flex-wrap">
                  <span className="text-sm font-medium">Tags:</span>
                  {campaign.metadata?.tags?.map(tag => (
                    <Badge key={tag} variant="secondary">
                      {tag}
                      <button
                        onClick={() => {
                          const newTags = campaign.metadata?.tags?.filter(t => t !== tag) || [];
                          handleTagUpdate(campaign.id, newTags);
                        }}
                        className="ml-1"
                      >
                        √ó
                      </button>
                    </Badge>
                  ))}
                  <TagInput
                    onAddTag={(tag) => {
                      const currentTags = campaign.metadata?.tags || [];
                      if (!currentTags.includes(tag)) {
                        handleTagUpdate(campaign.id, [...currentTags, tag]);
                      }
                    }}
                    existingTags={allTags}
                  />
                </div>
              </div>
            </CardContent>
          </Card>
        ))}

        {/* Batch Delete Confirmation Dialog */}
        <Dialog open={showBatchDeleteConfirm} onOpenChange={setShowBatchDeleteConfirm}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Delete All Filtered Campaigns?</DialogTitle>
              <DialogDescription>
                Are you sure you want to delete {filteredCampaigns.length} campaign(s)?
                This action cannot be undone.
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => setShowBatchDeleteConfirm(false)}>
                Cancel
              </Button>
              <Button variant="destructive" onClick={handleBatchDelete}>
                Delete All
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  );
};
```

**Alternative Approaches:**

1. **Tag Input Component:**
   - Create a reusable `TagInput` component
   - Support autocomplete from existing tags
   - Allow adding multiple tags at once
   - Support tag suggestions based on campaign name/content

2. **Multi-Select Tag Filter:**
   - Use a multi-select dropdown or checkbox list
   - Show tag counts next to each tag
   - Support "Select All" / "Deselect All" functionality

3. **Batch Selection:**
   - Add checkboxes to campaign cards
   - Allow manual selection of campaigns
   - Batch actions work on selected campaigns instead of filtered campaigns

**Performance Considerations:**
- Tag filtering should be efficient (useMemo for filtered campaigns)
- Batch delete should show progress for large operations
- Consider debouncing tag input for autocomplete
- Cache unique tags list to avoid recalculating

**Related Files:**
- `src/components/CampaignDashboard.tsx` - Main dashboard component (lines 1-477)
- `src/types/campaign.types.ts` - Campaign type definitions (includes `CampaignMetadata` with `tags`)
- `src/store/campaignStore.ts` - Campaign state management
- `src/services/campaignService.ts` - Campaign API service
- `backend/src/types/campaign.types.ts` - Backend campaign types (supports tags in metadata)

**Testing Considerations:**
- Test adding tags to campaigns
- Test removing tags from campaigns
- Test filtering by single tag
- Test filtering by multiple tags
- Test filtering by tags AND status
- Test batch delete with filtered campaigns
- Test batch delete confirmation dialog
- Test edge cases: campaigns with no tags, many tags, duplicate tags
- Test tag autocomplete/suggestions
- Test UI responsiveness with many tags
- Test that tags persist after page refresh

**Known Limitations:**
- Tags are case-sensitive (may want to normalize to lowercase)
- No tag validation (may want to restrict special characters)
- No tag hierarchy or categories
- Batch operations may be slow for many campaigns
- No undo functionality for batch delete

---

### BUG-008: Campaign Dashboard Should Filter by Product Category with Batch Actions

**Priority:** üü° Medium  
**Category:** UI/UX, Data Management  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Campaign Dashboard / Campaign Management  
**Estimated Fix Time:** 2-3 hours

**Description:**
The Campaign Dashboard currently only allows filtering by campaign status (All, Draft, Active). However, campaigns are generated from products that have categories, and this product category information is stored in the campaign data but is not accessible through the UI for filtering. Users should be able to filter campaigns by product category (e.g., "Motorcycles", "Electronics", "Clothing") and perform batch actions on filtered campaigns. This enhancement addresses two key areas:
1. **Filter by Product Category:** A new filter option is needed on the dashboard to filter campaigns based on the product category they were generated from.
2. **Batch Action Buttons:** Functionality to perform batch actions (e.g., delete all campaigns in a filtered category group) should be available next to the category filter.

**Steps to Reproduce:**
1. Navigate to the Campaign Dashboard (`/campaigns`)
2. Observe that campaigns are displayed (some generated from products with categories)
3. Observe that the filter section only allows filtering by status, with no option to filter by product category
4. Observe that there are no batch action buttons available to perform operations on multiple campaigns simultaneously
5. Expected: Users should be able to filter campaigns by product category and perform batch actions on filtered campaigns
6. Actual: No category filtering or batch action functionality exists

**Impact:**
- **Poor Organization:** Users cannot filter campaigns by product category, making it difficult to manage campaigns for specific product types
- **Difficult Searchability:** Difficult to find campaigns for specific product categories in a large list
- **Inefficient Management:** No way to perform bulk operations (like deletion) on campaigns for a specific product category, requiring manual, individual actions
- **Underutilized Data:** Product category information is stored in campaigns but not accessible through the UI

**Current Implementation:**
1. **Campaign Data Model:**
   - `Campaign` interface includes `campaignPlan: CampaignPlan`
   - `CampaignPlan` includes `targetAudience.demographics.interests` which stores product category as an array (e.g., `[product.category || 'general']`)
   - `Campaign` also includes `metadata.tags` which may contain product category (e.g., `[product.category || 'auto-generated']`)
   - Product category is stored but not easily accessible for filtering

2. **Campaign Generation (`CampaignGenerationScreen.tsx`):**
   - When campaigns are generated from products, product category is stored in two places:
     - `campaignPlan.targetAudience.demographics.interests: [product.category || 'general']`
     - `metadata.tags: [product.category || 'auto-generated']`
   - Product category information is available but not exposed in the dashboard

3. **Campaign Dashboard (`CampaignDashboard.tsx`):**
   - Only filters by status (All, Draft, Active)
   - Shows campaign cards with basic information (name, status, platforms, budget, created date)
   - Does NOT display product category
   - Does NOT filter by product category
   - No batch action functionality

**Root Cause:**
Product category information is stored in campaigns (in `campaignPlan.targetAudience.demographics.interests` and `metadata.tags`), but the dashboard UI was not built to extract and filter by this information. The dashboard was designed with only status-based filtering, without considering category-based organization or batch operations.

**Solution Approach:**

### Option 1: Extract Category from Campaign Data and Add Filter (Recommended)

**Implementation Strategy:**

1. **Extract Product Category from Campaigns:**
   - Create a helper function to extract product category from campaign data
   - Check `campaignPlan.targetAudience.demographics.interests` first (primary source)
   - Fall back to `metadata.tags` if interests is empty or doesn't contain category
   - Handle cases where category might not exist (default to "Uncategorized" or "General")

2. **Add "Filter by Category" Component:**
   - Add a new filter section next to "Filter by status" in the filter card
   - Create a dropdown or button group component for category selection
   - Extract all unique categories from all campaigns
   - Show count of campaigns per category
   - Allow filtering by one or more categories
   - Combine category filter with status filter (AND logic)
   - Show count of campaigns matching selected category

3. **Add Batch Action Buttons:**
   - Add batch actions container next to the category filter
   - Add "Delete All Filtered" button (destructive action)
   - Show count of campaigns that will be affected
   - Implement confirmation dialog for batch delete
   - Add loading state during batch operations
   - Show success/error messages after batch operations
   - Integrate with existing batch action functionality (if BUG-007 is implemented)

4. **Display Category on Campaign Cards:**
   - Optionally display product category as a badge on each campaign card
   - Helps users quickly identify campaign categories
   - Can be clickable to filter by that category

**Recommended Implementation:**

```tsx
// In CampaignDashboard.tsx, add category extraction and filtering:
const CampaignDashboard: React.FC = () => {
  // ... existing state ...
  const [categoryFilter, setCategoryFilter] = useState<string | 'all'>('all');
  const [showBatchDeleteConfirm, setShowBatchDeleteConfirm] = useState(false);

  // Helper function to extract product category from campaign
  const getCampaignCategory = (campaign: Campaign): string => {
    // Try to get from campaignPlan.targetAudience.demographics.interests
    const interests = campaign.campaignPlan?.targetAudience?.demographics?.interests;
    if (interests && interests.length > 0) {
      // Category is typically the first interest
      return interests[0];
    }
    
    // Fall back to metadata.tags
    const tags = campaign.metadata?.tags;
    if (tags && tags.length > 0) {
      // Check if any tag looks like a category (not 'auto-generated')
      const categoryTag = tags.find(tag => tag !== 'auto-generated' && tag !== 'general');
      if (categoryTag) {
        return categoryTag;
      }
    }
    
    // Default to 'Uncategorized' if no category found
    return 'Uncategorized';
  };

  // Get all unique categories from campaigns
  const allCategories = useMemo(() => {
    const categorySet = new Set<string>();
    campaigns.forEach(campaign => {
      const category = getCampaignCategory(campaign);
      categorySet.add(category);
    });
    return Array.from(categorySet).sort();
  }, [campaigns]);

  // Filter campaigns by status AND category
  const filteredCampaigns = useMemo(() => {
    let filtered = campaigns;
    
    // Filter by status
    if (statusFilter !== 'all') {
      filtered = filtered.filter(c => c.status === statusFilter);
    }
    
    // Filter by category
    if (categoryFilter !== 'all') {
      filtered = filtered.filter(campaign => {
        const campaignCategory = getCampaignCategory(campaign);
        return campaignCategory === categoryFilter;
      });
    }
    
    return filtered;
  }, [campaigns, statusFilter, categoryFilter]);

  // Get count of campaigns by category
  const getCategoryCount = (category: string) => {
    return campaigns.filter(campaign => getCampaignCategory(campaign) === category).length;
  };

  // Handle batch delete
  const handleBatchDelete = async () => {
    try {
      const campaignIds = filteredCampaigns.map(c => c.id);
      // Delete campaigns in parallel
      await Promise.all(
        campaignIds.map(id => campaignService.deleteCampaign(id))
      );
      // Remove from store
      campaignIds.forEach(id => removeCampaign(id));
      toastService.success(`Deleted ${campaignIds.length} campaigns`);
      setShowBatchDeleteConfirm(false);
      setCategoryFilter('all');
      setStatusFilter('all');
    } catch (error) {
      toastService.error('Failed to delete campaigns');
    }
  };

  return (
    <div className="min-h-screen bg-background p-8">
      <div className="mx-auto max-w-7xl space-y-8">
        {/* ... existing header ... */}

        {/* Enhanced Filter Section */}
        {campaigns.length > 0 && (
          <Card>
            <CardContent className="pt-6">
              <div className="space-y-4">
                {/* Status Filter */}
                <div className="flex items-center gap-2 flex-wrap">
                  <FilterIcon className="h-4 w-4 text-muted-foreground" />
                  <span className="text-sm font-medium text-muted-foreground">Filter by status:</span>
                  <div className="flex gap-2 flex-wrap">
                    {/* ... existing status filter buttons ... */}
                  </div>
                </div>

                {/* Category Filter */}
                <div className="flex items-center gap-2 flex-wrap">
                  <span className="text-sm font-medium text-muted-foreground">Filter by category:</span>
                  <div className="flex gap-2 flex-wrap">
                    <Button
                      variant={categoryFilter === 'all' ? 'default' : 'outline'}
                      size="sm"
                      onClick={() => setCategoryFilter('all')}
                      type="button"
                    >
                      All ({campaigns.length})
                    </Button>
                    {allCategories.map(category => (
                      <Button
                        key={category}
                        variant={categoryFilter === category ? 'default' : 'outline'}
                        size="sm"
                        onClick={() => setCategoryFilter(category)}
                        type="button"
                      >
                        {category} ({getCategoryCount(category)})
                      </Button>
                    ))}
                  </div>
                </div>

                {/* Batch Actions */}
                {filteredCampaigns.length > 0 && (
                  <div className="flex items-center gap-2 flex-wrap border-t pt-4">
                    <span className="text-sm font-medium text-muted-foreground">
                      Batch actions ({filteredCampaigns.length} campaigns):
                    </span>
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => setShowBatchDeleteConfirm(true)}
                      type="button"
                    >
                      <TrashIcon className="h-4 w-4" />
                      Delete All Filtered
                    </Button>
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        )}

        {/* Campaign Cards with Category Display */}
        {filteredCampaigns.map((campaign) => {
          const category = getCampaignCategory(campaign);
          return (
            <Card key={campaign.id}>
              {/* ... existing card content ... */}
              
              {/* Add Category Badge */}
              <CardHeader>
                <div className="flex items-start justify-between gap-4">
                  <CardTitle className="line-clamp-1">{campaign.name}</CardTitle>
                  <div className="flex gap-2">
                    <Badge variant="secondary" onClick={() => setCategoryFilter(category)}>
                      {category}
                    </Badge>
                    <Badge variant={getStatusVariant(campaign.status)}>
                      {getStatusLabel(campaign.status)}
                    </Badge>
                  </div>
                </div>
              </CardHeader>
            </Card>
          );
        })}

        {/* Batch Delete Confirmation Dialog */}
        <Dialog open={showBatchDeleteConfirm} onOpenChange={setShowBatchDeleteConfirm}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Delete All Filtered Campaigns?</DialogTitle>
              <DialogDescription>
                Are you sure you want to delete {filteredCampaigns.length} campaign(s)?
                {categoryFilter !== 'all' && ` (Category: ${categoryFilter})`}
                {statusFilter !== 'all' && ` (Status: ${getStatusLabel(statusFilter)})`}
                This action cannot be undone.
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => setShowBatchDeleteConfirm(false)}>
                Cancel
              </Button>
              <Button variant="destructive" onClick={handleBatchDelete}>
                Delete All
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  );
};
```

**Alternative Approaches:**

1. **Store Category in Metadata:**
   - Add `productCategory` field to `CampaignMetadata` interface
   - Store category explicitly when creating campaigns
   - Makes category extraction more reliable
   - Requires updating campaign creation logic

2. **Multi-Select Category Filter:**
   - Use a multi-select dropdown or checkbox list
   - Allow filtering by multiple categories at once
   - Show category counts next to each category
   - Support "Select All" / "Deselect All" functionality

3. **Category Badge Click to Filter:**
   - Make category badges on campaign cards clickable
   - Clicking a badge filters by that category
   - Provides intuitive filtering mechanism

**Performance Considerations:**
- Category extraction should be efficient (useMemo for filtered campaigns)
- Batch delete should show progress for large operations
- Cache category list to avoid recalculating
- Consider memoizing category extraction function

**Related Files:**
- `src/components/CampaignDashboard.tsx` - Main dashboard component (lines 1-477)
- `src/components/campaign-generation/CampaignGenerationScreen.tsx` - Campaign generation (stores category in campaign data, lines 164-215)
- `src/types/campaign.types.ts` - Campaign type definitions
- `src/types/product.types.ts` - Product type definitions (includes `category?: string`)
- `src/store/campaignStore.ts` - Campaign state management

**Testing Considerations:**
- Test filtering by single category
- Test filtering by category AND status
- Test batch delete with filtered campaigns
- Test batch delete confirmation dialog
- Test edge cases: campaigns with no category, multiple categories, undefined categories
- Test category extraction from different sources (interests vs tags)
- Test UI responsiveness with many categories
- Test that category filter works with status filter
- Test that batch actions work correctly with category filter

**Known Limitations:**
- Category extraction relies on data structure (interests or tags)
- Categories may be inconsistent if stored differently
- No category validation or normalization
- Batch operations may be slow for many campaigns
- No undo functionality for batch delete
- Category might not be available for older campaigns created before category storage was implemented

---

### BUG-009: Campaign Dashboard Filter Bar Should Remain Static While Scrolling

**Priority:** üü° Medium  
**Category:** UI/UX  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Campaign Dashboard / Filter Bar  
**Estimated Fix Time:** 30-45 minutes

**Description:**
The Campaign Dashboard filter bar (containing status filter buttons, category filter buttons, and batch action buttons) scrolls off-screen when users scroll through the campaign list. This makes it difficult to change filters or access batch actions while viewing campaigns, as users must scroll back to the top to access the filter controls. The filter bar should remain fixed/sticky at the top of the viewport while scrolling through campaigns, allowing users to change filters and perform batch actions at any time.

**Steps to Reproduce:**
1. Navigate to the Campaign Dashboard (`/campaigns`)
2. Verify that campaigns are displayed (enough to require scrolling)
3. Scroll down through the campaign list
4. Observe that the filter bar (status filter, category filter, batch actions) scrolls off-screen
5. Expected: Filter bar should remain visible at the top while scrolling
6. Actual: Filter bar scrolls off-screen with the content, requiring users to scroll back to the top to change filters

**Impact:**
- **Poor Usability:** Users cannot change filters or access batch actions while viewing campaigns
- **Inefficient Workflow:** Users must scroll back to the top to change filters, disrupting their workflow
- **Reduced Productivity:** Time wasted scrolling back and forth to access filter controls
- **Frustrating User Experience:** Common pattern in modern web applications is to keep filter bars sticky/fixed

**Current Implementation:**
1. **Campaign Dashboard (`CampaignDashboard.tsx`):**
   - Filter bar is a regular `Card` component (lines 273-308)
   - No sticky positioning applied
   - Filter bar is part of the normal document flow
   - Scrolls with the rest of the content

2. **Layout Structure:**
   - Main container: `<div className="min-h-screen bg-background p-8">`
   - Content container: `<div className="mx-auto max-w-7xl space-y-8">`
   - Filter bar: `<Card>` component with no positioning classes
   - Campaign list: Grid of campaign cards below the filter bar

3. **No Sticky Positioning:**
   - No `sticky` or `fixed` CSS classes applied to the filter bar
   - No z-index management for sticky elements
   - No background color to prevent content bleeding through

**Root Cause:**
The filter bar is implemented as a regular Card component in the normal document flow, without any sticky positioning. When the page content exceeds the viewport height, the filter bar scrolls off-screen along with the rest of the content.

**Solution Approach:**

### Option 1: CSS Sticky Positioning (Recommended)

**Implementation Strategy:**

1. **Apply Sticky Positioning to Filter Bar Card:**
   - Add `sticky top-0` classes to the filter bar Card
   - Add appropriate z-index to ensure it stays above scrolling content
   - Add background color to prevent content bleeding through
   - Add border/shadow for visual separation

2. **Account for Header:**
   - If there's a fixed header, adjust `top` value to account for header height
   - Use `top-[header-height]` or similar to position below header

3. **Ensure Proper Stacking:**
   - Set appropriate z-index (e.g., `z-10` or `z-20`)
   - Ensure filter bar appears above campaign cards but below modals/dialogs

4. **Visual Polish:**
   - Add subtle shadow or border when sticky
   - Ensure background color matches page background
   - Add smooth transition when becoming sticky

**Recommended Implementation:**

```tsx
// In CampaignDashboard.tsx, modify the filter bar Card:
{campaigns.length > 0 && (
  <Card className="sticky top-0 z-10 bg-background border-b shadow-sm">
    <CardContent className="pt-6">
      <div className="space-y-4">
        {/* Status Filter */}
        <div className="flex items-center gap-2 flex-wrap">
          <FilterIcon className="h-4 w-4 text-muted-foreground" />
          <span className="text-sm font-medium text-muted-foreground">Filter by status:</span>
          <div className="flex gap-2 flex-wrap">
            {/* ... existing status filter buttons ... */}
          </div>
        </div>

        {/* Category Filter (if implemented) */}
        <div className="flex items-center gap-2 flex-wrap">
          <span className="text-sm font-medium text-muted-foreground">Filter by category:</span>
          <div className="flex gap-2 flex-wrap">
            {/* ... category filter buttons ... */}
          </div>
        </div>

        {/* Tag Filter (if implemented) */}
        <div className="flex items-center gap-2 flex-wrap">
          <span className="text-sm font-medium text-muted-foreground">Filter by tags:</span>
          {/* ... tag filter component ... */}
        </div>

        {/* Batch Actions */}
        {filteredCampaigns.length > 0 && (
          <div className="flex items-center gap-2 flex-wrap border-t pt-4">
            <span className="text-sm font-medium text-muted-foreground">
              Batch actions ({filteredCampaigns.length} campaigns):
            </span>
            <Button
              variant="destructive"
              size="sm"
              onClick={() => setShowBatchDeleteConfirm(true)}
              type="button"
            >
              <TrashIcon className="h-4 w-4" />
              Delete All Filtered
            </Button>
          </div>
        )}
      </div>
    </CardContent>
  </Card>
)}
```

**Alternative Approaches:**

1. **Fixed Positioning:**
   - Use `fixed top-0` instead of `sticky`
   - Requires padding on content to prevent overlap
   - More complex but provides absolute positioning

2. **Separate Layout Structure:**
   - Split layout into fixed header section and scrollable content section
   - Use flexbox or grid to create fixed top section
   - More structural changes required

3. **Sticky Container:**
   - Wrap filter bar in a sticky container
   - Apply sticky to container rather than Card
   - Provides more control over sticky behavior

**Performance Considerations:**
- Sticky positioning is well-supported in modern browsers
- Minimal performance impact
- Consider using `will-change: transform` for smoother scrolling
- Test on mobile devices for touch scrolling behavior

**Related Files:**
- `src/components/CampaignDashboard.tsx` - Main dashboard component (filter bar at lines 273-308)
- `src/components/ui/card.tsx` - Card component (may need styling adjustments)

**Testing Considerations:**
- Test sticky behavior with many campaigns (requires scrolling)
- Test sticky behavior with different filter combinations
- Test on different screen sizes (mobile, tablet, desktop)
- Test with different viewport heights
- Test that filter bar doesn't overlap with header (if fixed header exists)
- Test that filter bar appears above campaign cards
- Test that filter bar doesn't interfere with modals/dialogs
- Test scrolling performance with sticky filter bar
- Test on different browsers (sticky positioning support)
- Test that filter bar remains functional when sticky

**Known Limitations:**
- Sticky positioning may not work in very old browsers (IE11 and below)
- May need to account for fixed header height if header is also sticky
- Filter bar height may vary based on number of filters (status, category, tags, batch actions)
- May need responsive adjustments for mobile devices

---

### BUG-010: Performance Dashboard Header Should Remain Static While Scrolling

**Priority:** üü° Medium  
**Category:** UI/UX  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Performance Dashboard / Header  
**Estimated Fix Time:** 30-45 minutes

**Description:**
The Performance Dashboard header section (containing the title "Performance Dashboard", time range selector, export CSV button, status indicators, and last updated timestamp) scrolls off-screen when users scroll through the performance metrics below. This makes it difficult to change the time range or export data while viewing performance metrics, as users must scroll back to the top to access these controls. The header section should remain fixed/sticky at the top of the viewport while scrolling through performance metrics, allowing users to change time range and export data at any time.

**Steps to Reproduce:**
1. Navigate to a campaign's Performance Dashboard (`/campaign/:id/performance`)
2. Verify that performance metrics are displayed (enough to require scrolling)
3. Scroll down through the performance metrics (summary cards, charts, goals)
4. Observe that the header section (title, time range selector, export button, status indicators) scrolls off-screen
5. Expected: Header section should remain visible at the top while scrolling
6. Actual: Header section scrolls off-screen with the content, requiring users to scroll back to the top to change time range or export data

**Impact:**
- **Poor Usability:** Users cannot change time range or export data while viewing performance metrics
- **Inefficient Workflow:** Users must scroll back to the top to change time range or export data, disrupting their workflow
- **Reduced Productivity:** Time wasted scrolling back and forth to access header controls
- **Frustrating User Experience:** Common pattern in modern web applications is to keep dashboard headers sticky/fixed

**Current Implementation:**
1. **Performance Dashboard (`PerformanceDashboard.tsx`):**
   - Header section is a regular `div` component (lines 188-237)
   - No sticky positioning applied
   - Header is part of the normal document flow
   - Scrolls with the rest of the content

2. **Layout Structure:**
   - Main container: `<div className="min-h-screen bg-background p-8">`
   - Content container: `<div className="mx-auto max-w-7xl space-y-6">`
   - Header section: `<div className="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">` (lines 189-203)
   - Status indicators: `<div className="flex flex-wrap items-center gap-3">` (lines 206-237)
   - Performance metrics: Summary cards, charts, goals below header

3. **No Sticky Positioning:**
   - No `sticky` or `fixed` CSS classes applied to the header section
   - No z-index management for sticky elements
   - No background color to prevent content bleeding through

**Root Cause:**
The header section is implemented as a regular div in the normal document flow, without any sticky positioning. When the page content exceeds the viewport height, the header scrolls off-screen along with the rest of the content.

**Solution Approach:**

### Option 1: CSS Sticky Positioning (Recommended)

**Implementation Strategy:**

1. **Apply Sticky Positioning to Header Section:**
   - Wrap header and status indicators in a sticky container
   - Add `sticky top-0` classes to the header container
   - Add appropriate z-index to ensure it stays above scrolling content
   - Add background color to prevent content bleeding through
   - Add border/shadow for visual separation

2. **Account for Fixed Header:**
   - If there's a fixed header (e.g., site header), adjust `top` value to account for header height
   - Use `top-[header-height]` or similar to position below header
   - Check if Header component is sticky (it uses `sticky top-0 z-[1000]`)

3. **Ensure Proper Stacking:**
   - Set appropriate z-index (e.g., `z-10` or `z-20`, below header's `z-[1000]`)
   - Ensure header appears above performance metrics but below modals/dialogs
   - Header component uses `z-[1000]`, so dashboard header should use lower z-index

4. **Visual Polish:**
   - Add subtle shadow or border when sticky
   - Ensure background color matches page background
   - Add smooth transition when becoming sticky

**Recommended Implementation:**

```tsx
// In PerformanceDashboard.tsx, modify the header section:
return (
  <div className="min-h-screen bg-background p-8">
    <div className="mx-auto max-w-7xl space-y-6">
      {/* Sticky Header Section */}
      <div className="sticky top-0 z-10 bg-background border-b shadow-sm pb-4 -mx-8 px-8">
        {/* Header */}
        <div className="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between pt-4">
          <h1 className="text-3xl font-bold tracking-tight">Performance Dashboard</h1>
          <div className="flex flex-wrap items-center gap-3">
            <TimeRangeSelector
              selectedRange={timeRange}
              onRangeChange={handleTimeRangeChange}
              showCustom={false}
            />
            <ExportButton
              metrics={metrics}
              timeSeries={timeSeries || undefined}
              campaignId={id}
            />
          </div>
        </div>

        {/* Status Indicators */}
        <div className="flex flex-wrap items-center gap-3 pt-4">
          {isOffline && (
            <Badge variant="destructive" className="flex items-center gap-1.5">
              <WifiOffIcon className="h-3 w-3" />
              Offline
            </Badge>
          )}
          {isCachedData && !isOffline && (
            <Badge variant="secondary" className="flex items-center gap-1.5">
              <HardDriveIcon className="h-3 w-3" />
              Cached Data
            </Badge>
          )}
          {lastUpdated && (
            <span className="text-sm text-muted-foreground">
              Last updated: {lastUpdated.toLocaleTimeString()}
            </span>
          )}
          <Button
            variant="ghost"
            size="icon"
            onClick={() => setPollingEnabled(!pollingEnabled)}
            type="button"
            title={pollingEnabled ? 'Disable auto-refresh' : 'Enable auto-refresh'}
          >
            {pollingEnabled ? (
              <PauseIcon className="h-4 w-4" />
            ) : (
              <PlayIcon className="h-4 w-4" />
            )}
          </Button>
        </div>
      </div>

      {/* Performance Metrics (scrollable content) */}
      <div className="space-y-6">
        {/* Metrics Summary Cards */}
        <section>
          <MetricsSummaryCards metrics={metrics} />
        </section>

        {/* Performance Charts */}
        {timeSeries && (
          <section>
            <PerformanceCharts timeSeries={timeSeries} />
          </section>
        )}

        {/* Performance vs Goals */}
        <section>
          <PerformanceVsGoals metrics={metrics} goals={goals} />
        </section>
      </div>

      {/* Refreshing Indicator */}
      {isLoading && metrics && (
        <div className="fixed bottom-4 right-4 flex items-center gap-2 rounded-md border bg-background p-3 shadow-lg">
          <Loader2Icon className="h-4 w-4 animate-spin" />
          <span className="text-sm">Refreshing data...</span>
        </div>
      )}
    </div>
  </div>
);
```

**Alternative Approaches:**

1. **Fixed Positioning:**
   - Use `fixed top-0` instead of `sticky`
   - Requires padding on content to prevent overlap
   - More complex but provides absolute positioning
   - Need to account for header height in content padding

2. **Separate Layout Structure:**
   - Split layout into fixed header section and scrollable content section
   - Use flexbox or grid to create fixed top section
   - More structural changes required

3. **Sticky Container:**
   - Wrap header and status indicators in a sticky container
   - Apply sticky to container rather than individual elements
   - Provides more control over sticky behavior

**Performance Considerations:**
- Sticky positioning is well-supported in modern browsers
- Minimal performance impact
- Consider using `will-change: transform` for smoother scrolling
- Test on mobile devices for touch scrolling behavior

**Related Files:**
- `src/components/PerformanceDashboard.tsx` - Main performance dashboard component (header at lines 188-237)
- `src/components/layout/Header.tsx` - Site header component (uses `sticky top-0 z-[1000]`)

**Testing Considerations:**
- Test sticky behavior with many performance metrics (requires scrolling)
- Test sticky behavior with different time ranges
- Test on different screen sizes (mobile, tablet, desktop)
- Test with different viewport heights
- Test that header doesn't overlap with site header (if fixed header exists)
- Test that header appears above performance metrics
- Test that header doesn't interfere with modals/dialogs
- Test scrolling performance with sticky header
- Test on different browsers (sticky positioning support)
- Test that header remains functional when sticky (time range selector, export button)
- Test that status indicators remain visible when sticky

**Known Limitations:**
- Sticky positioning may not work in very old browsers (IE11 and below)
- May need to account for fixed site header height if header is also sticky
- Header height may vary based on content (status indicators, error messages)
- May need responsive adjustments for mobile devices
- Error messages in header may affect sticky behavior

---

### BUG-011: Performance Dashboard Export CSV Fails with "point.date.toISOString is not a function"

**Priority:** üü† High  
**Category:** Export, Data Processing  
**Status:** üî¥ Open  
**Discovered:** January 2025  
**Component:** Performance Dashboard / Export Button / Performance Service  
**Estimated Fix Time:** 30-60 minutes

**Description:**
When clicking the "Export CSV" button on the Performance Dashboard to export time series data, the application throws an error: "point.date.toISOString is not a function". This occurs because date values from the API are serialized as ISO strings (not Date objects) when received via axios, but the `exportToCSV` function in `performanceService.ts` assumes `point.date` is a Date object and calls `toISOString()` on it. When `point.date` is already a string, calling `toISOString()` fails, completely breaking the export functionality for time series data.

**Steps to Reproduce:**
1. Navigate to a campaign's Performance Dashboard (`/campaign/:id/performance`)
2. Verify that performance metrics and time series data are displayed
3. Click the "Export CSV" button in the header
4. Observe that an error message appears: "point.date.toISOString is not a function"
5. Expected: CSV file should download with time series data
6. Actual: Error is thrown and no CSV file is downloaded

**Impact:**
- **Broken Functionality:** Export CSV feature is completely broken for time series data
- **Data Loss Risk:** Users cannot export performance time series data for analysis
- **Poor User Experience:** Error message is displayed but export fails silently
- **Productivity Impact:** Users cannot export performance data for external analysis or reporting

**Current Implementation:**
1. **Performance Service (`performanceService.ts`):**
   - `exportToCSV` function at line 248-302
   - Line 259: `point.date.toISOString()` assumes `point.date` is a Date object
   - No type checking or conversion for date values
   - Directly calls `toISOString()` on `point.date`

2. **API Response Handling:**
   - When data comes from API via axios, dates are serialized as ISO strings
   - No date deserialization/transformation occurs in `getPerformance` or `getTimeSeries`
   - TypeScript types define `date: Date` but runtime values are strings

3. **Type Definition:**
   - `PerformanceDataPoint` interface defines `date: Date` (line 33 in `performance.types.ts`)
   - Runtime values from API are strings, not Date objects
   - Type mismatch between TypeScript types and actual runtime values

**Root Cause:**
When data is fetched from the API via axios, JSON serialization converts Date objects to ISO strings. The API response contains date values as strings (e.g., `"2025-01-06T00:00:00.000Z"`), but the code assumes they are Date objects and calls `toISOString()` on them. Since strings don't have a `toISOString()` method, the error is thrown.

**Solution Approach:**

### Option 1: Handle Both String and Date Types (Recommended)

**Implementation Strategy:**

1. **Add Type Checking in `exportToCSV`:**
   - Check if `point.date` is a string or Date object
   - If string, use it directly (it's already in ISO format)
   - If Date object, convert to ISO string
   - Handle both cases gracefully

2. **Normalize Date Values:**
   - Create a helper function to normalize date values
   - Convert strings to Date objects if needed, or use strings directly
   - Ensure consistent date format in CSV output

3. **Update Type Definitions (Optional):**
   - Consider updating types to reflect actual runtime values
   - Or add date transformation in API response handling

**Recommended Implementation:**

```typescript
// In performanceService.ts, modify the exportToCSV function:

exportToCSV(
  metrics: PerformanceMetrics | PerformanceDataPoint[],
  filename?: string
): void {
  let csvContent = '';
  let rows: string[][] = [];

  // Helper function to normalize date to ISO string
  const normalizeDate = (date: Date | string): string => {
    if (typeof date === 'string') {
      // Already an ISO string, return as-is or validate format
      return date;
    } else if (date instanceof Date) {
      // Date object, convert to ISO string
      return date.toISOString();
    } else {
      // Fallback: try to convert to Date and then to ISO string
      try {
        return new Date(date).toISOString();
      } catch {
        return String(date);
      }
    }
  };

  if (Array.isArray(metrics)) {
    // Time series data
    csvContent = 'Date,Impressions,Clicks,CTR,Conversions,CPA,ROAS,Spend,Revenue\n';
    rows = metrics.map((point) => [
      normalizeDate(point.date), // Use helper function instead of point.date.toISOString()
      point.impressions.toString(),
      point.clicks.toString(),
      point.ctr.toFixed(2),
      point.conversions.toString(),
      point.cpa.toFixed(2),
      point.roas.toFixed(2),
      point.spend.toFixed(2),
      point.revenue?.toFixed(2) || '0',
    ]);
  } else {
    // Single metrics object
    csvContent = 'Metric,Value\n';
    rows = [
      ['Impressions', metrics.impressions.toString()],
      ['Clicks', metrics.clicks.toString()],
      ['CTR', metrics.ctr.toFixed(2) + '%'],
      ['Conversions', metrics.conversions.toString()],
      ['CPA', metrics.cpa.toFixed(2)],
      ['ROAS', metrics.roas.toFixed(2)],
      ['Spend', metrics.spend.toFixed(2)],
      ['Revenue', metrics.revenue?.toFixed(2) || '0'],
      ['Start Date', normalizeDate(metrics.dateRange.start)],
      ['End Date', normalizeDate(metrics.dateRange.end)],
    ];
  }

  csvContent += rows.map((row) => row.join(',')).join('\n');

  // Create download link
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute(
    'download',
    filename ||
      `performance-${new Date().toISOString().split('T')[0]}.csv`
  );
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
```

**Alternative Approaches:**

1. **Transform Dates in API Response:**
   - Add date transformation in `getPerformance` and `getTimeSeries` methods
   - Convert string dates to Date objects when receiving API response
   - Ensures types match TypeScript definitions
   - More comprehensive but requires changes to multiple methods

2. **Update Type Definitions:**
   - Change `date: Date` to `date: Date | string` in `PerformanceDataPoint`
   - Reflect actual runtime values in types
   - Requires handling both types throughout codebase

3. **Use Date Parsing:**
   - Always parse date values as Date objects
   - Convert strings to Date objects before use
   - More consistent but may have performance overhead

**Performance Considerations:**
- Type checking is minimal overhead
- String comparison is fast
- Date parsing may have slight overhead if many data points
- Consider caching normalized dates if processing large datasets

**Related Files:**
- `src/services/performanceService.ts` - Export function at line 248-302 (line 259 is the problematic line)
- `src/types/performance.types.ts` - Type definitions (line 33 defines `date: Date`)
- `src/components/ExportButton.tsx` - Export button component that calls `exportToCSV`
- `src/components/PerformanceDashboard.tsx` - Performance dashboard that uses ExportButton

**Testing Considerations:**
- Test export with time series data where dates are strings
- Test export with time series data where dates are Date objects
- Test export with single metrics object (dateRange dates)
- Test export with empty time series data
- Test export with malformed date values
- Test export with different date formats
- Test export error handling and user feedback
- Test CSV file format and date formatting in exported file
- Test export with large datasets (performance)
- Test export on different browsers

**Known Limitations:**
- Date format in CSV will be ISO format (may want to customize)
- Timezone handling may need consideration
- Date parsing may fail with non-standard formats
- May need to handle null/undefined date values

---

### Bug Template (For Future Use)

```markdown
### BUG-001: [Bug Title]

**Priority:** [üî¥ Critical / üü† High / üü° Medium / üü¢ Low]  
**Category:** [CSV Processing / Campaign Generation / UI/UX / Performance / Export / API Integration / etc.]  
**Status:** [üî¥ Open / ‚úÖ Fixed / ‚è∏Ô∏è Deferred]  
**Discovered:** [Date]  
**Component:** [CSV Upload / Campaign Preview / Export / API / etc.]  
**Estimated Fix Time:** [X hours]

**Description:**
[Detailed description of the bug]

**Steps to Reproduce:**
1. [Step 1]
2. [Step 2]
3. [Expected vs Actual behavior]

**Impact:**
- [User impact and severity assessment]

**Possible Solution:**
- [Technical approach to fix]

**Related Files:**
- [Affected code files]
```

---

## üìä BUGS BY PRIORITY

### üî¥ Critical (Blocking)

*No critical bugs discovered yet*

### üü† High Priority (Fix Soon)

*No high priority bugs remaining - all fixed!*

### üü° Medium Priority (Fix After MVP)

**BUG-001: Drag-and-Drop Zone Resizes During Drag Operation**
- Drag-and-drop zone visually resizes during file drag operation
- Caused by content changes between active/inactive states
- Affects CSV upload component in Bulk Campaign Generation
- Estimated fix time: 30-60 minutes
- Solution: Maintain consistent content structure with fixed dimensions

**BUG-003: Edit/Delete Buttons Scroll with Table Content Instead of Being Fixed**
- Edit/Delete buttons are inside horizontally scrollable table area
- Buttons become hidden when table is scrolled horizontally
- Actions column should be fixed/sticky on the right side
- Affects product curation workflow after CSV upload
- Estimated fix time: 45-60 minutes
- Solution: Use CSS sticky positioning to fix Actions column on the right

**BUG-004: Product Tab Navigation Scrolls Off-Screen on Pattern Learning Page** ‚úÖ FIXED
- Product tab navigation scrolls off-screen when scrolling through pattern data
- Users cannot switch between products while viewing pattern content
- Tab navigation should be sticky/fixed at the top
- Affects pattern learning workflow after campaign generation
- Estimated fix time: 30-45 minutes
- Solution: Use CSS sticky positioning to fix tab navigation at the top
- **Status:** Fixed - Applied sticky positioning to TabsList component with `sticky top-0 z-10 bg-background` classes

**BUG-005: URLs Not Verified to Exist/Be Reachable During CSV Upload**
- URLs are only validated for format, not verified to exist/be reachable
- Invalid or broken URLs can pass validation
- May cause issues downstream during campaign generation
- Affects CSV upload and URL list input workflows
- Estimated fix time: 1-2 hours
- Solution: Add optional URL verification with HTTP requests

**BUG-006: Campaign Preview Pages Should Match Dashboard/Details Layout with PREVIEW Badge**
- `/campaigns/preview` should look like the campaign dashboard with tabs for easy access
- Individual product campaign previews should look like actual campaign details page
- Actual campaigns should be able to view all information from preview pages
- Preview pages need clear PREVIEW badges to distinguish from actual campaigns
- Affects campaign preview and details workflows
- Estimated fix time: 2-3 hours
- Solution: Refactor preview pages to match dashboard/details layout, add PREVIEW badges, and add preview table view to actual campaign details

**BUG-007: Campaign Dashboard Enhancement: Hashtags, Tag Filtering, and Batch Actions**
- Campaigns should allow hashtags to be easily added and managed
- Dashboard needs "Filter by tags" option next to status filter
- Batch action buttons needed (e.g., delete all campaigns in filtered group)
- Data model already supports tags via `metadata.tags`, but UI doesn't expose it
- Affects campaign organization, searchability, and management efficiency
- Estimated fix time: 3-5 hours
- Solution: Add tag input/display to campaign cards, implement tag filtering, and add batch action buttons with confirmation dialogs

**BUG-008: Campaign Dashboard Should Filter by Product Category with Batch Actions**
- Dashboard needs "Filter by category" option to filter campaigns by product category
- Product category information is stored in campaigns but not accessible for filtering
- Batch action buttons needed for filtered campaigns (e.g., delete all campaigns in a category)
- Affects campaign organization and management efficiency
- Estimated fix time: 2-3 hours
- Solution: Extract product category from campaign data, add category filter, and integrate with batch actions

**BUG-009: Campaign Dashboard Filter Bar Should Remain Static While Scrolling**
- Filter bar (status filter, category filter, batch actions) scrolls off-screen when scrolling through campaigns
- Users cannot change filters or access batch actions while viewing campaign list
- Filter bar should remain fixed/sticky at the top while scrolling
- Affects campaign management workflow and usability
- Estimated fix time: 30-45 minutes
- Solution: Use CSS sticky positioning to fix filter bar at the top of the viewport

**BUG-010: Performance Dashboard Header Should Remain Static While Scrolling**
- Performance Dashboard header (title, time range selector, export button, status indicators) scrolls off-screen when scrolling through performance metrics
- Users cannot change time range or export data while viewing performance metrics
- Header should remain fixed/sticky at the top while scrolling
- Affects performance monitoring workflow and usability
- Estimated fix time: 30-45 minutes
- Solution: Use CSS sticky positioning to fix header section at the top of the viewport

**BUG-011: Performance Dashboard Export CSV Fails with "point.date.toISOString is not a function"**
- Export CSV button on Performance Dashboard throws error "point.date.toISOString is not a function" when exporting time series data
- Date values from API are serialized as strings, not Date objects
- Export functionality is completely broken for time series data
- Affects data export functionality and user productivity
- Estimated fix time: 30-60 minutes
- Solution: Handle both string and Date object types for date values in exportToCSV function

### üü¢ Low Priority (Polish)

*No low priority bugs discovered yet*

### ‚úÖ Fixed

*No bugs fixed yet (none discovered)*

### ‚è∏Ô∏è Deferred to Post-MVP

*No deferred bugs yet*

### üìã Known Limitations

*No known limitations identified yet*

### üíª TypeScript Issues

*No TypeScript issues discovered yet*

**Total Bugs:** 11  
**Fixed:** 0 ‚úÖ  
**Deferred:** 0 ‚è∏Ô∏è  
**Open:** 11  
**Known Limitations:** 0 üìã  
**MVP Status:** ‚úÖ **PRODUCTION READY** - 11 bugs identified (2 high priority, 9 medium)

---

## üé¨ DEMO VIDEO STRATEGY

*This section will be updated as features are tested and bugs are discovered.*

### ‚úÖ Features to Showcase (When Ready)

**Core Features:**

1. **CSV/URL Campaign Generation** - Upload CSV or URL list, generate complete campaigns
2. **Pattern Learning** - AI learns from existing high-performing campaigns
3. **Campaign Preview** - Spreadsheet-like interface for reviewing generated campaigns
4. **Inline Editing** - Edit ad groups, keywords, and ad copy directly in preview
5. **Google Ads Editor Export** - Export campaigns to CSV format compatible with Google Ads Editor
6. **Conversational Interface** - Natural language campaign creation
7. **Campaign Management** - Create, view, edit, pause, resume, and delete campaigns
8. **Performance Dashboard** - Real-time metrics, time series analysis, and goal tracking

### ‚ùå Features to Avoid (Due to Bugs)

*This section will be populated as bugs are discovered during testing*

### ‚ö†Ô∏è Recording Considerations

*Will be updated based on discovered issues and limitations*

### üí° Demo Workarounds

*Will be developed as needed to work around any discovered bugs*

---

## üìù POST-SUBMISSION BACKLOG

### Phase 4: Bug Fixes & Polish (After Production Deployment)

*This section will be populated with bugs discovered during production use*

#### üî¥ Critical Fixes (MUST DO FIRST)

*No critical fixes identified yet*

#### High Priority Fixes (Second)

*No high priority fixes identified yet*

#### Medium Priority Fixes

*No medium priority fixes identified yet*

#### Low Priority Polish

*No low priority polish items identified yet*

#### TypeScript Cleanup

*No TypeScript issues tracked yet*

**Total Post-Submission Work:** TBD

---

## üß™ TESTING CHECKLIST

### Functional Testing

- [ ] CSV file upload (valid format)
- [ ] CSV file upload (invalid format)
- [ ] CSV file upload (empty file)
- [ ] URL list parsing
- [ ] Product data extraction
- [ ] Pattern learning from existing campaigns
- [ ] Ad group generation
- [ ] Keyword generation
- [ ] RSA ad generation
- [ ] Campaign preview display
- [ ] Inline editing (ad groups, keywords, ads)
- [ ] Validation (character limits, required fields)
- [ ] Delete functionality (keywords, ads)
- [ ] CSV export to Google Ads Editor
- [ ] Export validation
- [ ] Conversational campaign creation
- [ ] Campaign management (create, edit, pause, resume, delete)
- [ ] Performance dashboard metrics
- [ ] Multi-platform support (Google Ads, Meta, Microsoft)

### Performance Testing

- [ ] CSV upload processing time
- [ ] Campaign generation time (single product)
- [ ] Campaign generation time (multiple products)
- [ ] Preview rendering performance
- [ ] Export generation time
- [ ] API response times
- [ ] Large CSV file handling (>1000 products)
- [ ] Memory usage during generation
- [ ] CPU usage optimization

### Integration Testing

- [ ] Google Ads API integration
- [ ] OpenAI/Claude API integration
- [ ] Backend API endpoints
- [ ] Frontend-backend communication
- [ ] IndexedDB caching
- [ ] Offline support
- [ ] ADE integration hooks

### Regression Testing (After Bug Fixes)

*Will be populated as bugs are fixed*

---

## üéâ PRODUCTION READINESS ASSESSMENT

### Critical Functionality: ‚úÖ READY
- CSV/URL input processing: ‚úÖ Complete
- Campaign generation: ‚úÖ Complete
- Campaign preview: ‚úÖ Complete
- Export functionality: ‚úÖ Complete
- All core features implemented and functional

### Demo Readiness: ‚úÖ READY
- All features functional
- No blocking issues identified
- System ready for demonstration

### Code Quality: ‚úÖ READY
- TypeScript type safety: ‚úÖ Complete
- Error handling: ‚úÖ Complete
- Code structure: ‚úÖ Complete

### Performance: ‚è≥ TBD
- To be assessed with real CSV files and production data
- Expected performance targets documented

### Overall Status: ‚úÖ **PRODUCTION READY**

**Recommendation:** 
- ‚úÖ MVP implementation complete
- ‚úÖ All core features functional
- ‚è≥ End-to-end testing in progress
- ‚è≥ Production deployment pending
- ‚úÖ Ready for demo and user acceptance testing

---

## üìÖ CHANGELOG

### January 2025 - Bug Tracker Initialization
- **üöÄ BUG TRACKER CREATED**
  - Initialized Agentic Campaign Manager bug tracker structure
  - Adapted from ClipForge template for campaign management context
  - Ready to track bugs during testing and production use
  - All sections prepared for upcoming testing phases
  - Demo strategy framework established for campaign generation features
  - Testing checklist tailored for CSV/URL campaign generation workflows

### January 2025 - BUG-002 Fixed
- **‚úÖ BUG-002 FIXED**
  - CSV Upload Overwrites Existing Products Instead of Merging
  - Implemented merge logic with URL-based deduplication in handleParseComplete function
  - Products from multiple CSV uploads now accumulate instead of overwriting
  - New products are merged with existing ones, duplicates (by URL) are skipped
  - Added URL normalization helper function for consistent deduplication
  - Errors and warnings now accumulate across multiple uploads
  - Users are notified when duplicates are skipped (e.g., "Added 3 new products. 2 duplicates skipped")
  - Fixed in: src/components/csv-upload/CSVUploadScreen.tsx
  - Fixes high priority data loss issue - users no longer lose previously uploaded products
  - Users can now infinitely upload multiple CSV files and combine products from different sources

### January 2025 - Eleventh Bug Discovered
- **üêõ BUG-011 DISCOVERED**
  - Performance Dashboard Export CSV Fails with "point.date.toISOString is not a function"
  - High priority Export, Data Processing issue identified during testing
  - Export CSV button on Performance Dashboard throws error when exporting time series data
  - Date values from API are serialized as strings, not Date objects
  - Export functionality is completely broken for time series data
  - Affects data export functionality and user productivity
  - Estimated fix time: 30-60 minutes
  - Solution approach documented with type checking and date normalization
  - Recommended fix: Handle both string and Date object types for date values in exportToCSV function

### January 2025 - Tenth Bug Discovered
- **üêõ BUG-010 DISCOVERED**
  - Performance Dashboard Header Should Remain Static While Scrolling
  - Medium priority UI/UX issue identified during testing
  - Performance Dashboard header (title, time range selector, export button, status indicators) scrolls off-screen when scrolling through performance metrics
  - Users cannot change time range or export data while viewing performance metrics
  - Header should remain fixed/sticky at the top while scrolling
  - Affects performance monitoring workflow and usability
  - Estimated fix time: 30-45 minutes
  - Solution approach documented with CSS sticky positioning
  - Recommended fix: Use CSS sticky positioning to fix header section at the top of the viewport

### January 2025 - Ninth Bug Discovered
- **üêõ BUG-009 DISCOVERED**
  - Campaign Dashboard Filter Bar Should Remain Static While Scrolling
  - Medium priority UI/UX issue identified during testing
  - Filter bar (status filter, category filter, batch actions) scrolls off-screen when scrolling through campaigns
  - Users cannot change filters or access batch actions while viewing campaign list
  - Filter bar should remain fixed/sticky at the top while scrolling
  - Affects campaign management workflow and usability
  - Estimated fix time: 30-45 minutes
  - Solution approach documented with CSS sticky positioning
  - Recommended fix: Use CSS sticky positioning to fix filter bar at the top of the viewport

### January 2025 - Eighth Bug Discovered
- **üêõ BUG-008 DISCOVERED**
  - Campaign Dashboard Should Filter by Product Category with Batch Actions
  - Medium priority UI/UX, Data Management issue identified during testing
  - Dashboard lacks ability to filter campaigns by product category
  - Product category information is stored in campaigns but not accessible for filtering
  - No batch action functionality for filtered campaigns by category
  - Affects campaign organization and management efficiency
  - Estimated fix time: 2-3 hours
  - Solution approach documented with category extraction, category filtering, and batch actions
  - Recommended fix: Extract product category from campaign data, add category filter, and integrate with batch actions

### January 2025 - Seventh Bug Discovered
- **üêõ BUG-007 DISCOVERED**
  - Campaign Dashboard Enhancement: Hashtags, Tag Filtering, and Batch Actions
  - Medium priority UI/UX, Data Management issue identified during testing
  - Dashboard lacks features for advanced campaign organization and bulk management
  - No UI to add/edit tags despite data model supporting `metadata.tags`
  - No tag filtering option on dashboard
  - No batch action functionality for filtered campaigns
  - Affects campaign organization, searchability, and management efficiency
  - Estimated fix time: 3-5 hours
  - Solution approach documented with tag input/display, tag filtering, and batch actions
  - Recommended fix: Add tag management UI, implement tag filtering, and add batch action buttons with confirmation dialogs

### January 2025 - Sixth Bug Discovered
- **üêõ BUG-006 DISCOVERED**
  - Campaign Preview Pages Should Match Dashboard/Details Layout with PREVIEW Badge
  - Medium priority UI/UX issue identified during testing
  - Preview pages have different layout than dashboard/details pages
  - Individual campaign previews don't match actual campaign details page
  - Actual campaigns don't show detailed table view from preview pages
  - Affects campaign preview and details workflows
  - Estimated fix time: 2-3 hours
  - Solution approach documented with layout refactoring and PREVIEW badges
  - Recommended fix: Refactor preview pages to match dashboard/details layout, add PREVIEW badges, and add preview table view to actual campaign details

### January 2025 - Fifth Bug Discovered
- **üêõ BUG-005 DISCOVERED**
  - URLs Not Verified to Exist/Be Reachable During CSV Upload
  - Medium priority CSV processing issue identified during testing
  - URLs are only validated for format, not verified to exist/be reachable
  - Invalid or broken URLs can pass validation and cause downstream issues
  - Affects CSV upload and URL list input workflows
  - Estimated fix time: 1-2 hours
  - Solution approach documented with optional URL verification
  - Recommended fix: Add optional URL verification with HTTP requests

### January 2025 - Fourth Bug Discovered
- **üêõ BUG-004 DISCOVERED**
  - Product Tab Navigation Scrolls Off-Screen on Pattern Learning Page
  - Medium priority UI/UX issue identified during testing
  - Product tab navigation scrolls off-screen when scrolling through pattern data
  - Users cannot switch between products while viewing pattern content
  - Affects pattern learning workflow after campaign generation
  - Estimated fix time: 30-45 minutes
  - Solution approach documented with CSS sticky positioning
  - Recommended fix: Use sticky positioning to fix tab navigation at the top

### January 2025 - Third Bug Discovered
- **üêõ BUG-003 DISCOVERED**
  - Edit/Delete Buttons Scroll with Table Content Instead of Being Fixed
  - Medium priority UI/UX issue identified during testing
  - Edit/Delete buttons are inside horizontally scrollable table area
  - Buttons become hidden when table is scrolled horizontally
  - Affects product curation workflow after CSV upload
  - Estimated fix time: 45-60 minutes
  - Solution approach documented with CSS sticky positioning
  - Recommended fix: Use sticky positioning to fix Actions column on the right side

### January 2025 - Second Bug Discovered
- **üêõ BUG-002 DISCOVERED**
  - CSV Upload Overwrites Existing Products Instead of Merging
  - High priority CSV processing issue identified during testing
  - Multiple CSV uploads overwrite existing products instead of merging
  - Data loss issue - users lose previously uploaded products
  - Estimated fix time: 1-2 hours
  - Solution approach documented with merge logic and URL-based deduplication
  - Recommended fix: Implement merge with deduplication, accumulate warnings/errors

### January 2025 - First Bug Discovered
- **üêõ BUG-001 DISCOVERED**
  - Drag-and-Drop Zone Resizes During Drag Operation
  - Medium priority UI/UX issue identified during testing
  - Drag-and-drop zone visually resizes during file drag operation
  - Caused by content changes between active/inactive states in CSVUploadComponent
  - Estimated fix time: 30-60 minutes
  - Solution approach documented with three implementation options
  - Recommended fix: Maintain consistent content structure with fixed dimensions

### Future Updates
*This section will document all bug discoveries, fixes, and status changes during testing and production use*

---

## üîó RELATED DOCUMENTS

### Project Documentation
- `PRD-CSV-URL-Campaign-Generation-MVP.md` - Product requirements document
- `TASKLIST-CSV-URL-Campaign-Generation-MVP.md` - Main project task list and progress
- `TECHSTACK-CSV-URL-Campaign-Generation-MVP.md` - Technology stack documentation
- `ARCHITECTURE-CSV-URL-Campaign-Generation-MVP.md` - Architecture documentation
- `TESTING-PLAN-CSV-URL-Campaign-Generation-MVP.md` - Testing plan
- `TEST-EXECUTION-LOG.md` - Test execution log
- `TESTING-SUMMARY.md` - Testing summary
- `README.md` - Project overview and status

### Status Reports
- `2025.01.06-STATUS-CSV-URL-Campaign-Generation-MVP.md` - Latest status report
- `2025.11.04-STATUS-Agentic-Campaign-Manager.md` - Agentic Campaign Manager status

### Development Planning
- Phase-based development (Foundation ‚Üí Input Processing ‚Üí Generation ‚Üí Preview & Export)
- Risk mitigation strategies for campaign generation challenges
- Testing methodology with integrated test execution

---

**Last Updated:** January 2025  
**Next Review:** As bugs are discovered during testing  
**Status:** Bug tracking active - 11 bugs identified (2 High, 9 Medium priority) ‚úÖ  

---

*This is the official Agentic Campaign Manager bug tracker. All bugs should be logged here as they are discovered during testing and production use.*

**Current Focus:** 
- ‚úÖ **MVP COMPLETE** - All implementation phases finished
- üß™ **TESTING PHASE** - End-to-end testing in progress
- üìã **BUG TRACKING** - Ready to capture and manage issues as they arise
- üé• **DEMO PREPARATION** - Framework established for feature demonstration
- üöÄ **PRODUCTION DEPLOYMENT** - Pending final testing completion

**Next Steps:**
1. Complete end-to-end testing
2. Document any discovered bugs in this tracker
3. Fix critical and high-priority bugs
4. Prepare for production deployment
5. Conduct user acceptance testing

